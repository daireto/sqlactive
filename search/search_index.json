{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#overview","title":"Overview","text":"<p>SQLActive is a lightweight and asynchronous ActiveRecord-style wrapper for SQLAlchemy. Brings Django-like queries, automatic timestamps, nested eager loading, and serialization/deserialization for SQLAlchemy models.</p> <p>Heavily inspired by sqlalchemy-mixins.</p> <p>The source code for this project is available on GitHub.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Asynchronous Support: Async operations for better scalability.</li> <li>ActiveRecord-like methods: Perform CRUD operations with a syntax similar   to Peewee.</li> <li>Django-like queries: Perform intuitive and   expressive queries.</li> <li>Nested eager loading: Load nested relationships efficiently.</li> <li>Automatic timestamps: Auto-manage <code>created_at</code> and <code>updated_at</code> fields.</li> <li>Serialization/deserialization: Serialize and deserialize models to/from   dict or JSON easily.</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<p>Python&gt;=3.10</p> <p>Dependencies: - sqlalchemy&gt;=2.0.0</p>"},{"location":"#installation","title":"Installation","text":"<p>You can simply install sqlactive from PyPI:</p> <pre><code>pip install sqlactive\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import asyncio\n\nfrom sqlalchemy import String, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlactive import ActiveRecordBaseModel, DBConnection\n\n\n# Define a base class for your models (recommended)\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\n# Define the models\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    username: Mapped[str] = mapped_column(String(18), nullable=False, unique=True)\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n    user: Mapped['User'] = relationship(back_populates='posts')\n\n\n# Create a database connection instance\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=False)\n\nasync def example():\n    # Initialize SQLActive with the base model of your models\n    await conn.init_db(BaseModel)\n\n    # Create a record\n    user = await User.insert(username='John1234', name='John Doe', age=25)\n    post = Post(title='My post', body='Lorem ipsum...', rating=2, user=user)\n    await post.save()\n\n    # Retrieve a record\n    user = await User.get(1)\n\n    # Update a record\n    await user.update(name='John Doe', age=30)\n    post.rating = 3\n    await post.save()\n\n    # Delete a record\n    await user.delete()\n\n    # Find records\n    users = await User.where(User.name == 'John Doe').all()  # SQLAlchemy-like query\n    posts = await Post.where(title__contains='post').all()   # Django-like query\n\n    # Serialize a record\n    user_dict = user.to_dict()\n    user_json = user.to_json()\n\n    # Deserialize a record\n    user = User.from_dict(user_dict)\n    user = User.from_json(user_json)\n\n\nif __name__ == '__main__':\n    asyncio.run(example())\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Please read the contribution guidelines.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE page for details.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can simply install sqlactive from the PyPI:</p> <pre><code>pip install sqlactive\n</code></pre>"},{"location":"getting-started/#tutorial","title":"Tutorial","text":""},{"location":"getting-started/#1-define-the-models","title":"1. Define the Models","text":"<p>The <code>ActiveRecordBaseModel</code> class provides a base class for your models.</p> <p>It inherits from:</p> <ul> <li><code>ActiveRecordMixin</code>: Provides a set of   ActiveRecord-like helper methods for interacting with the database.</li> <li><code>TimestampMixin</code>: Adds the <code>created_at</code> and   <code>updated_at</code> timestamp columns.</li> <li><code>SerializationMixin</code>: Provides serialization and   deserialization methods.</li> </ul> <p>It is recommended to define a <code>BaseModel</code> class that inherits from <code>ActiveRecordBaseModel</code> and use it as the base class for all models as shown in the following example:</p> <pre><code>from sqlalchemy import String, ForeignKey\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\nfrom sqlactive import ActiveRecordBaseModel\n\n\n# Define a base class for your models (recommended)\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\n# Define the models\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    username: Mapped[str] = mapped_column(String(18), nullable=False, unique=True)\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, index=True)\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n</code></pre> Warning <p>When defining a <code>BaseModel</code> class, don't forget to set <code>__abstract__</code> to <code>True</code> in the base class to avoid creating tables for the base class.</p> Tip <p>The models can directly inherit from the <code>ActiveRecordBaseModel</code> class:</p> <pre><code>from sqlactive import ActiveRecordBaseModel\n\nclass User(ActiveRecordBaseModel):\n    __tablename__ = 'users'\n    # ...\n</code></pre> <p>However, it is recommended to define a base model class for your models and inherit from it.</p> <p>Your base model class can also inherit directly from the mixins. For example, if you don't want to implement automatic timestamps don't inherit from <code>ActiveRecordBaseModel</code> class. Instead, inherit from <code>ActiveRecordMixin</code> and/or <code>SerializationMixin</code>:</p> <pre><code>from sqlactive import ActiveRecordMixin, SerializationMixin\n\nclass BaseModel(ActiveRecordMixin, SerializationMixin):\n    __abstract__ = True\n</code></pre>"},{"location":"getting-started/#2-initialize-the-database","title":"2. Initialize the Database","text":"<pre><code>from asyncio import current_task\nfrom sqlalchemy.ext.asyncio import (\n    create_async_engine,\n    async_sessionmaker,\n    async_scoped_session,\n)\nfrom sqlactive import ActiveRecordBaseModel\n\n# Connect to the database\nDATABASE_URL = 'sqlite+aiosqlite://'\nasync_engine = create_async_engine(DATABASE_URL, echo=False)\nasync_sessionmaker = async_sessionmaker(\n    bind=async_engine,\n    expire_on_commit=False,\n)\nasync_scoped_session = async_scoped_session(\n    async_sessionmaker,\n    scopefunc=current_task,\n)\n\n# Set the session\nBaseModel.set_session(async_scoped_session)\n\n# Initialize the tables\nasync with async_engine.begin() as conn:\n    await conn.run_sync(BaseModel.metadata.create_all)\n</code></pre> <p>The use of the <code>expire_on_commit</code> flag is explained in the warning of this section.</p> Tip <p>Use the <code>DBConnection</code> class as a shortcut to initialize the database. The <code>DBConnection</code> class is a wrapper around the <code>async_engine</code>, <code>async_sessionmaker</code> and <code>async_scoped_session</code> objects:</p> <pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=False)\nawait conn.init_db(BaseModel)\n</code></pre> <p>See the DB Connection Helper section for more information.</p>"},{"location":"getting-started/#3-perform-crud-operations","title":"3. Perform CRUD Operations","text":"<pre><code>user = await User.insert(username='John1234', name='John Doe', age=25)\nuser  # &lt;User #1&gt;\n\nuser.name = 'Johnny Doe'\nuser['age'] = 30\nawait user.save()\nuser.name  # Johnny Doe\n\nuser = await User.get(1)\nuser  # &lt;User #1&gt;\n\nawait user.update(name='John Doe', age=20)\nuser['name']  # John Doe\nuser.age  # 20\n\nawait user.delete()\n</code></pre> Danger <p>The <code>delete()</code> and <code>remove()</code> methods are not soft deletes methods. Both of them will permanently delete the row from the database. So, if you want to keep the row in the database, you can implement a custom soft delete method, i.e. using <code>save()</code> method to update the row with a flag indicating if the row is deleted or not (i.e. a boolean <code>is_deleted</code> column).</p> Tip <p>If you need to create a record for a short period of time, you can use the <code>with</code> statement:</p> <pre><code>with User(name='Bob', age=30) as user:\n    ...\n</code></pre> <p>The <code>with</code> statement will create the record and delete it at the end of the block.</p> <p>Check the Temporary Records documentation for more information.</p> <p>Also, check the Active Record Mixin API Reference to see all the available methods.</p>"},{"location":"getting-started/#4-perform-bulk-operations","title":"4. Perform Bulk Operations","text":"<pre><code>users = [\n    User(username='John1234', name='John Doe', age=20),\n    User(username='Jane1234', name='Jane Doe', age=21),\n    User(username='Bob1234', name='Bob Doe', age=22),\n]\n\nawait User.insert_all(users)\nusers = await User.find(username__endswith='Doe').all()\nusers  # [&lt;User #1&gt;, &lt;User #2&gt;]\n\nawait User.delete_all(users)\n\nusers = await User.find(username__endswith='Doe').all()\nusers  # []\n</code></pre> Tip <p>Check the Active Record Mixin API Reference to see all the available methods.</p>"},{"location":"getting-started/#5-perform-queries","title":"5. Perform Queries","text":"<p>Perform simple and complex queries with eager loading:</p> <pre><code>from sqlactive import JOINED, SUBQUERY\n\nuser = await User.where(name='John Doe').first()\nuser  # &lt;User #1&gt;\n\nposts = await Post.where(rating__in=[2, 3, 4], user___name__like='%Bi%').all()\nposts  # [&lt;Post #1&gt;, &lt;Post #2&gt;, &lt;Post #3&gt;]\n\nposts = await Post.sort('-rating', 'user___name').all()\nposts  # [&lt;Post #3&gt;, &lt;Post #1&gt;, &lt;Post #2&gt;, &lt;Post #4&gt;, ...]\n\ncomments = await Comment.join(Comment.user, Comment.post).unique_all()\ncomments  # [&lt;Comment 1&gt;, &lt;Comment 2&gt;, &lt;Comment 3&gt;, &lt;Comment 4&gt;, ...]\n\nuser = await User.with_subquery(User.posts).first()\nuser  # &lt;User #1&gt;\nuser.posts  # [&lt;Post #1&gt;, &lt;Post #2&gt;, &lt;Post #3&gt;]\n\nschema = {\n    User.posts: JOINED,\n    User.comments: (SUBQUERY, {\n        Comment.post: SELECT_IN\n    }),\n}\nuser = await User.with_schema(schema).unique_first()\nuser.comments[0].post.title  # Lorem ipsum\n</code></pre> Warning <p>All relations used in filtering/sorting/grouping should be explicitly set, not just being a <code>backref</code>. See the About Relationships section for more information.</p> Tip <p>Check the Active Record Mixin API Reference to see all the available methods.</p> <p>For more flexibility, the low-level <code>filter_expr()</code>, <code>order_expr()</code>, <code>column_expr()</code> and <code>eager_expr()</code> methods can be used.</p> <p>Example of <code>filter_expr()</code> method usage</p> <pre><code>Post.filter(*Post.filter_expr(rating__gt=2, body='text'))\n# or\nsession.query(Post).filter(*Post.filter_expr(rating__gt=2, body='text'))\n</code></pre> <p>It's like filter in SQLALchemy, but also allows magic operators like <code>rating__gt</code>.</p> Note <p>Low-level <code>filter_expr()</code>, <code>order_expr()</code>, <code>column_expr()</code> and <code>eager_expr()</code> methods are very low-level and does NOT do magic Django-like joins. Use <code>smart_query()</code> for that:</p> <pre><code>query = User.smart_query(\n    criterion=(or_(User.age == 30, User.age == 32),),\n    filters={'username__like': '%8'},\n    sort_columns=(User.username,),\n    sort_attrs=('-created_at',),\n    group_columns=(User.username,),\n    group_attrs=['age'],\n    schema={\n        User.posts: JOINED,\n        User.comments: (SUBQUERY, {\n            Comment.post: SELECT_IN\n        }),\n    },\n)\n</code></pre> <p>Check the Smart Query Mixin API Reference for more details about the <code>smart_query()</code> method and the low-level methods.</p> <p>To perform native SQLAlchemy queries asynchronously, you can use the <code>execute()</code> method:</p> <pre><code>from sqlalchemy import select, func\nfrom sqlactive import ActiveRecordBaseModel, execute\n\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n    # ...\n\nquery = select(User.age, func.count(User.id)).group_by(User.age)\nresult = await execute(query, BaseModel)\n# [(20, 1), (22, 4), (25, 12)]\n</code></pre> <p>See the Native SQLAlchemy queries documentation for more information.</p>"},{"location":"getting-started/#6-manage-timestamps","title":"6. Manage Timestamps","text":"<p>Timestamps (<code>created_at</code> and <code>updated_at</code>) are automatically managed:</p> <pre><code>user = await User.insert(username='John1234', name='John Doe', age=25)\nuser.created_at  # 2024-12-28 23:00:51\nuser.updated_at  # 2024-12-28 23:00:51\n\nawait asyncio.sleep(1)\n\nawait user.update(name='Johnny Doe')\nuser.updated_at  # 2024-12-28 23:00:52\n</code></pre> Tip <p>Check the <code>TimestampMixin</code> class to know how to customize the timestamps behavior.</p>"},{"location":"getting-started/#7-serialization-and-deserialization","title":"7. Serialization and Deserialization","text":"<p>Models can be serialized/deserialized to/from dictionaries using the <code>to_dict()</code> and <code>from_dict()</code> methods:</p> <pre><code>user = await User.insert(username='John1234', name='John Doe', age=25)\nuser_dict = user.to_dict()\nuser_dict  # {'id': 1, 'username': 'John1234', 'name': 'John Doe', ...}\n\nuser = User.from_dict(user_dict)\nuser.name  # John Doe\n</code></pre> <p>Also, models can be serialized/deserialized to/from JSON using the <code>to_json()</code> and <code>from_json()</code> methods:</p> <pre><code>user = await User.insert(username='John1234', name='John Doe', age=25)\nuser_json = user.to_json()\nuser_json  # {\"id\": 1, \"username\": \"John1234\", \"name\": \"John Doe\", ...}\n\nuser = User.from_json(user_json)\nuser.name  # John Doe\n</code></pre>"},{"location":"about/contributing/","title":"Contributing Guidelines","text":"<p>Thank you for your interest in contributing to SQLActive! Please take a moment to review this document before submitting a pull request.</p>"},{"location":"about/contributing/#why-should-you-read-these-guidelines","title":"Why should you read these guidelines?","text":"<p>Following these guidelines ensures that your contributions align with the project's standards, respect the time of maintainers, and facilitate a smooth collaboration process.</p>"},{"location":"about/contributing/#ground-rules","title":"Ground Rules","text":""},{"location":"about/contributing/#responsibilities","title":"Responsibilities","text":"<ul> <li>Ensure cross-platform compatibility for all changes (Windows, macOS,   Debian, and Ubuntu Linux).</li> <li>Follow the PEP 8 style   guide and use single quotes (<code>'</code>) for strings.</li> <li>Adhere to clean code principles, such as SOLID, DRY, and   KISS. Avoid unnecessary complexity.</li> <li>Use Active Record patterns for database interactions where applicable.</li> <li>Keep contributions small and focused. One feature or fix per pull request.</li> <li>Discuss significant changes or enhancements transparently by opening an   issue first.</li> <li>Be respectful and welcoming. Follow the   Python Community Code of Conduct.</li> </ul>"},{"location":"about/contributing/#tools-and-workflow","title":"Tools and Workflow","text":"<ul> <li>Use Ruff as the linter and formatter (Black could be an alternative).</li> <li>Write NumPy-style docstrings for all public functions, classes, attributes,   and properties.</li> <li>Commit messages and pull requests must follow specific prefixes described   here.</li> </ul>"},{"location":"about/contributing/#your-first-pull-request","title":"Your First Pull Request","text":""},{"location":"about/contributing/#getting-started","title":"Getting Started","text":"<p>If this is your first pull request:</p> <ul> <li>Watch the How to Contribute to an Open Source Project on GitHub   video series.</li> <li>Search for existing discussions to ensure your contribution doesn't duplicate   ongoing efforts.</li> </ul>"},{"location":"about/contributing/#setup-instructions","title":"Setup Instructions","text":"<ol> <li>Fork the repository.</li> <li>Clone your fork to your local machine.</li> <li>Set up a virtual environment:     <pre><code>python -m venv venv\nsource venv/bin/activate  # on Windows: venv\\Scripts\\activate\n</code></pre></li> <li>Install dependencies:     <pre><code>pip install -r requirements.txt\n</code></pre></li> <li>Run tests and <code>Ruff</code> linter to confirm the setup:     <pre><code>python -m unittest discover -s tests -t .\npython -m ruff check .\n</code></pre></li> </ol>"},{"location":"about/contributing/#reporting-issues","title":"Reporting Issues","text":""},{"location":"about/contributing/#security-issues","title":"Security Issues","text":"<p>For security vulnerabilities, do not open an issue. Instead, email dairoandres123@gmail.com.</p> <p>In order to determine whether you are dealing with a security issue, ask yourself these two questions:</p> <ul> <li>Can I access something that's not mine, or something I shouldn't have   access to?</li> <li>Can I disable something for other people?</li> </ul> <p>If the answer to either of those two questions are \"yes\", then you're probably dealing with a security issue. Note that even if you answer \"no\" to both questions, you may still be dealing with a security issue, so if you're unsure, just email dairoandres123@gmail.com.</p>"},{"location":"about/contributing/#filing-a-bug-report","title":"Filing a Bug Report","text":"<p>When reporting a bug, please include:</p> <ol> <li>Python version.</li> <li>Operating system and architecture.</li> <li>Steps to reproduce the issue.</li> <li>Expected behavior.</li> <li>Actual behavior, including error messages and stack traces.</li> </ol> <p>General questions should go to the python-discuss mailing list instead of the issue tracker. The Pythonists there will answer or ask you to file an issue if you have tripped over a bug.</p>"},{"location":"about/contributing/#suggesting-features-or-enhancements","title":"Suggesting Features or Enhancements","text":"<p>To suggest a feature:</p> <ol> <li>Open an issue on the GitHub issues page.</li> <li>Clearly describe the desired feature, its purpose, and its expected behavior.</li> <li>If possible, include examples or PseudoCode.</li> </ol>"},{"location":"about/contributing/#code-conventions","title":"Code Conventions","text":""},{"location":"about/contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 guidelines, enforced by Ruff and Black.</li> <li>Use single quotes (<code>'</code>) for strings unless escaping becomes cumbersome.</li> <li>Write docstrings in NumPy style. Example:     <pre><code>def add(a: int, b: int) -&gt; int:\n    \"\"\"\n    Add two integers.\n\n    Parameters\n    ----------\n    a : int\n        First integer.\n    b : int\n        Second integer.\n\n    Returns\n    -------\n    int\n        Sum of the integers.\n\n    Examples\n    --------\n    &gt;&gt;&gt; add(1, 2)\n    3\n    \"\"\"\n    return a + b\n</code></pre></li> </ul>"},{"location":"about/contributing/#commit-message-format","title":"Commit Message Format","text":"<p>Use the Conventional Commits format for commit messages. It says that the commit message consists of a header, a body and a footer. The header has a special format that includes a type, an optional scope and a subject:</p> <pre><code>&lt;type&gt;(&lt;optional scope&gt;): &lt;subject&gt;\n&lt;BLANK LINE&gt;\n&lt;optional body&gt;\n&lt;BLANK LINE&gt;\n&lt;optional footer&gt;\n</code></pre> <p>Any line of the commit message cannot be longer 100 characters! This allows the message to be easier to read on GitHub as well as in various git tools.</p> <p>The footer should contain a closing reference to an issue if any.</p>"},{"location":"about/contributing/#types","title":"Types","text":"<ul> <li><code>build</code>: Changes that affect the build system or external dependencies.   Example: \"build: Update build-backend in pyproject.toml\".</li> <li><code>ci</code>: Changes to the CI configuration files and scripts.   Example: \"ci: Add GitHub Actions workflow for testing\".</li> <li><code>docs</code>: Documentation only changes.   Example: \"docs: Add documentation for new feature\".</li> <li><code>feat</code>: A new feature.   Example: \"feat: Add support for PostgreSQL database connections\".</li> <li><code>fix</code>: A bug fix.   Example: \"fix: Resolve issue with incorrect date display\".</li> <li><code>perf</code>: A code change that improves performance.   Example: \"perf: Optimize database query for faster response times\".</li> <li><code>refactor</code>: A code change that neither fixes a bug nor adds a feature,   for example, renaming a variable.   Example: \"refactor: Extract user profile component\".</li> <li><code>revert</code>: Described below.</li> <li><code>style</code>: Changes that do not affect the meaning of the code   (white-space, formatting, missing semi-colons, etc).   Example: \"style: Apply code formatting according to PEP 8\".</li> <li><code>test</code>: Adding missing tests or correcting existing tests.   Example: \"test: Add unit tests for user service\".</li> <li><code>chore</code>: Other changes that don't modify src or test files.   Example: \"chore: Update dependencies to latest versions\".</li> </ul>"},{"location":"about/contributing/#revert","title":"Revert","text":"<p>If the commit reverts a previous commit, it should begin with <code>revert:</code>, followed by the header of the reverted commit. In the body it should say: \"This reverts commit  because of .\", where the hash is the SHA of the commit being reverted. <p>Example: <pre><code>revert: feat: Add support for PostgreSQL database connections\n\nThis reverts commit 1234567890abcdef1234567890abcdef12345678 because it\ncaused a breaking change.\n</code></pre></p>"},{"location":"about/contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<p>Before submitting a pull request:</p> <ol> <li>Add or update tests for your changes.</li> <li>Ensure all tests pass:     <pre><code>python -m unittest discover -s tests -t .\n</code></pre></li> <li>Check code linting:     <pre><code>python -m ruff check .\n</code></pre></li> <li>Update the documentation, if necessary.</li> <li>Provide a clear and descriptive pull request title and description.</li> </ol> <p>Pull requests titles should be short and descriptive, and should not exceed 72 characters. Also, must follow the specified commit message format.</p>"},{"location":"about/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Dairo Mosquera</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"api/active-record-mixin/","title":"Active Record Mixin","text":"<p>The <code>ActiveRecordMixin</code> class provides a set of ActiveRecord-like helper methods for SQLAlchemy models, allowing for more intuitive and chainable database operations with async/await support.</p> <p>It implements the functionality of both <code>Session</code> and <code>Smart Queries</code> mixins.</p> Info <p>The examples below assume the following models:</p> <pre><code>from sqlalchemy import ForeignKey, String\nfrom sqlalchemy.ext.hybrid import hybrid_method, hybrid_property\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom sqlactive.base_model import ActiveRecordBaseModel\n\n\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    username: Mapped[str] = mapped_column(\n        String(18), nullable=False, unique=True\n    )\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\n    @hybrid_property\n    def is_adult(self) -&gt; int:\n        return self.age &gt; 18\n\n    @hybrid_method\n    def older_than(self, other: 'User') -&gt; bool:\n        return self.age &gt; other.age\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n\n\nclass Product(BaseModel):\n    __tablename__ = 'products'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    description: Mapped[str] = mapped_column(String(100), nullable=False)\n    price: Mapped[float] = mapped_column(nullable=False)\n\n    sells: Mapped[list['Sell']] = relationship(\n        back_populates='product', viewonly=True\n    )\n\n\nclass Sell(BaseModel):\n    __tablename__ = 'sells'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    product_id: Mapped[int] = mapped_column(\n        ForeignKey('products.id'), primary_key=True\n    )\n    quantity: Mapped[int] = mapped_column(nullable=False)\n\n    product: Mapped['Product'] = relationship(back_populates='sells')\n</code></pre>"},{"location":"api/active-record-mixin/#usage","title":"Usage","text":"<p>To use the <code>ActiveRecordMixin</code>, create a base model class that inherits from it and set the <code>__abstract__</code> attribute to <code>True</code>:</p> <pre><code>from sqlalchemy import Mapped, mapped_column\nfrom sqlactive import ActiveRecordMixin\n\n\nclass BaseModel(ActiveRecordMixin):\n    __abstract__ = True\n\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n    # ...and more\n</code></pre> Tip <p>You can also make your base inherit from the <code>ActiveRecordBaseModel</code> class which is a combination of <code>ActiveRecordMixin</code>, <code>SerializationMixin</code> and <code>TimestampMixin</code>.</p>"},{"location":"api/active-record-mixin/#about-relationships","title":"About Relationships","text":"<p>All relations used in filtering/sorting/grouping should be explicitly set, not just being a <code>backref</code>. This is because SQLActive does not know the relation direction and cannot infer it. So, when defining a relationship like:</p> <pre><code>class User(BaseModel):\n    # ...\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n</code></pre> <p>It is required to define the reverse relationship:</p> <pre><code>class Post(BaseModel):\n    # ...\n    user: Mapped['User'] = relationship(back_populates='posts')\n</code></pre>"},{"location":"api/active-record-mixin/#core-features","title":"Core Features","text":""},{"location":"api/active-record-mixin/#creation-updating-and-deletion","title":"Creation, Updating, and Deletion","text":""},{"location":"api/active-record-mixin/#creating-records","title":"Creating Records","text":"<pre><code># Create a single record\nbob = await User.insert(name='Bob')\njoe = await User.create(name='Joe')  # Synonym for insert()\n\n# Create multiple records\nusers = [User(name='Alice'), User(name='Bob')]\nawait User.insert_all(users)  # Shortcut for save_all()\n</code></pre>"},{"location":"api/active-record-mixin/#updating-records","title":"Updating Records","text":"<pre><code># Update a single record\nawait user.update(name='Bob2')\n\n# Update multiple records\nusers = await User.where(age=25).all()\nfor user in users:\n    user.name = f\"{user.name} Jr.\"\nawait User.update_all(users)  # Shortcut for save_all()\n</code></pre>"},{"location":"api/active-record-mixin/#deleting-records","title":"Deleting Records","text":"<pre><code># Delete a single record\nawait user.delete()\nawait user.remove()  # Synonym for delete()\n\n# Delete multiple records\nusers = await User.where(age=25).all()\nawait User.delete_all(users)\n\n# Delete by primary keys\nawait User.destroy(1, 2, 3)  # Deletes users with IDs 1, 2, and 3\n</code></pre>"},{"location":"api/active-record-mixin/#temporary-records","title":"Temporary Records","text":"<p>If you need to create a record for a short period of time, you can use the <code>with</code> statement:</p> <pre><code>with User(name='Bob', age=30) as user:\n    ...\n</code></pre> <p>The <code>with</code> statement will create the record using the <code>save()</code> method. The record will be deleted at the end of the block using the <code>delete()</code>.</p> <p>Here is an example of using temporary records to test the <code>isnull</code> filter operator:</p> <pre><code>post1 = Post(\n    title='Lorem ipsum',\n    body='Lorem ipsum dolor sit amet, consectetur adipiscing elit.',\n    rating=4,\n    user_id=1,\n    topic='Some topic',  # this post has a topic\n)\npost2 = Post(\n    title='Lorem ipsum',\n    body='Lorem ipsum dolor sit amet, consectetur adipiscing elit.',\n    rating=4,\n    user_id=1,  # this post does not have a topic\n)\n\n# post1 and post2 will be deleted at the end of the block\nasync with post1, post2:\n\n    # If isnull=True, only posts without a topic must be returned\n    posts = await Post.where(topic__isnull=True).all()\n    assert all([p.topic is None for p in posts]) is True\n\n    # If isnull=False, only posts with a topic must be returned\n    posts = await Post.where(topic__isnull=False).all()\n    assert all([post.topic is not None for p in posts]) is True\n</code></pre>"},{"location":"api/active-record-mixin/#querying","title":"Querying","text":""},{"location":"api/active-record-mixin/#basic-queries","title":"Basic Queries","text":"<pre><code># Get all records\nusers = await User.all()\n\n# Get first record\nuser = await User.first()        # None if no results found\n\n# Get one record\nuser = await User.one()          # Raises if no results found\nuser = await User.one_or_none()  # Returns None if no results found\n</code></pre>"},{"location":"api/active-record-mixin/#filtering","title":"Filtering","text":"<p>The mixin supports both Django-like syntax and SQLAlchemy syntax for filtering:</p> <pre><code># Django-like syntax\nusers = await User.where(name__like='%John%').all()\nusers = await User.where(name__like='%John%', age=30).all()\n\n# SQLAlchemy syntax\nusers = await User.where(User.name == 'John Doe').all()\n\n# Mixed syntax\nusers = await User.where(User.age == 30, name__like='%John%').all()\n\n# Synonyms\nusers = await User.filter(name__like='%John%').all()\nuser = await User.find(name__like='%John%', age=30).one()\n</code></pre>"},{"location":"api/active-record-mixin/#sorting-and-pagination","title":"Sorting and Pagination","text":"<pre><code>from sqlalchemy.sql import asc, desc\n\n# Sorting (Django-like syntax)\nusers = await User.order_by('-created_at').all()          # Descending order\nusers = await User.order_by('name').all()                 # Ascending order\nusers = await User.order_by('-created_at', 'name').all()  # Multiple columns\n\n# Sorting (SQLAlchemy syntax)\nusers = await User.sort(User.created_at.desc()).all()  # Synonym for order_by()\nusers = await User.sort(asc(User.name)).all()\n\n# Sorting (mixed syntax)\nusers = await User.order_by('-created_at', User.name.asc()).all()\nusers = await User.sort('-age', asc(User.name)).all()\n\n# Pagination\nusers = await User.offset(10).limit(5).all()  # Skip 10, take 5\nusers = await User.skip(10).take(5).all()     # Same as above\n</code></pre>"},{"location":"api/active-record-mixin/#grouping","title":"Grouping","text":"<pre><code># Grouping (Django-like syntax)\nusers = await User.group_by(User.age).all()\nusers = await User.group_by(User.age, User.name).all()\n\n# Grouping (SQLAlchemy syntax)\nusers = await User.group_by('age').all()\nusers = await User.group_by('age', 'name').all()\n\n# Grouping (mixed syntax)\nusers = await User.group_by(User.age, 'name').all()\n</code></pre>"},{"location":"api/active-record-mixin/#eager-loading","title":"Eager Loading","text":""},{"location":"api/active-record-mixin/#join-loading","title":"Join Loading","text":"<pre><code>comment = await Comment.join(\n    Comment.user, Comment.post  # Left outer join\n).first()\n\ncomment = await Comment.join(\n    Comment.user,\n    (Comment.post, True)  # True means inner join\n).first()\n\ncomments = await Comment.join(Comment.user, Comment.post)\n    .unique_all()  # required for joinedload()\n</code></pre>"},{"location":"api/active-record-mixin/#subquery-loading","title":"Subquery Loading","text":"<pre><code>users = await User.with_subquery(\n    User.posts,            # subquery loading\n    (User.comments, True)  # True means selectinload\n).unique_all()     # important!\n\n# With limiting and sorting (important for correct results)\nusers = await User.with_subquery(User.posts)\n    .limit(1)\n    .sort('id')    # important!\n    .unique_all()  # important!\n</code></pre>"},{"location":"api/active-record-mixin/#complex-schema-loading","title":"Complex Schema Loading","text":"<pre><code>from sqlactive import JOINED, SUBQUERY\n\nschema = {\n    User.posts: JOINED,          # joinedload user\n    User.comments: (SUBQUERY, {  # load comments in separate query\n        Comment.user: JOINED     # but join user in this separate query\n    })\n}\n\nuser = await User.with_schema(schema).first()\n</code></pre>"},{"location":"api/active-record-mixin/#smart-queries","title":"Smart Queries","text":"<p>The <code>Smart Query Mixin</code> provides a powerful smart query builder that combines filtering, sorting, grouping and eager loading:</p> <pre><code>from sqlactive import JOINED\n\n# Complex query with multiple features\nusers = await User.smart_query(\n    criterion=(User.age &gt;= 18,),\n    filters={'name__like': '%John%'},\n    sort_columns=(User.username,),\n    sort_attrs=['-created_at'],\n    group_columns=(User.username,),\n    group_attrs=['age'],\n    schema={User.posts: JOINED}\n).all()\n</code></pre>"},{"location":"api/active-record-mixin/#api-reference","title":"API Reference","text":""},{"location":"api/active-record-mixin/#class-properties","title":"Class Properties","text":"<p>Most of class properties are inherited from <code>InspectionMixin</code>.</p>"},{"location":"api/active-record-mixin/#query","title":"query","text":"<pre><code>@classproperty\ndef query() -&gt; Select[tuple[Self]]\n</code></pre> <p>Return a new <code>sqlalchemy.sql.Select</code> for the model.</p> <p>This is a shortcut for <code>select(cls)</code>.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.query\nSELECT * FROM users\n</code></pre> <p>Is equivalent to: <pre><code>&gt;&gt;&gt; from sqlalchemy import select\n&gt;&gt;&gt; select(User)\nSELECT * FROM users\n</code></pre></p>"},{"location":"api/active-record-mixin/#instance-methods","title":"Instance Methods","text":""},{"location":"api/active-record-mixin/#fill","title":"fill","text":"<pre><code>def fill(**kwargs) -&gt; Self\n</code></pre> <p>Fill the object with passed values.</p> <p>Update the object's attributes with the provided values without saving to the database.</p> <p>Parameters</p> <ul> <li><code>kwargs</code>: Key-value pairs of columns to set.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>AttributeError</code>: If attribute doesn't exist.</li> <li><code>NoSettableError</code>: If attribute is not settable.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = User(name='Bob')\n&gt;&gt;&gt; user.name\nBob\n&gt;&gt;&gt; user.fill(name='Bob Williams', age=30)\n&gt;&gt;&gt; user.name\nBob Williams\n&gt;&gt;&gt; user.age\n30\n</code></pre>"},{"location":"api/active-record-mixin/#save","title":"save","text":"<pre><code>async def save() -&gt; Self\n</code></pre> <p>Save the current row.</p> Note <p>All database errors will trigger a rollback and be raised.</p> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>SQLAlchemyError</code>: If saving fails.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = User(name='Bob Williams', age=30)\n&gt;&gt;&gt; await user.save()\n</code></pre>"},{"location":"api/active-record-mixin/#update","title":"update","text":"<pre><code>async def update(**kwargs) -&gt; Self\n</code></pre> <p>Update the current row with the provided values.</p> <p>This is the same as calling <code>self.fill(**kwargs).save()</code>.</p> <p>Parameters</p> <ul> <li><code>kwargs</code>: Key-value pairs of attributes to update.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = User(name='Bob', age=30)\n&gt;&gt;&gt; user.name\nBob\n&gt;&gt;&gt; await user.update(name='Bob Williams', age=31)\n&gt;&gt;&gt; user.name\nBob Williams\n</code></pre>"},{"location":"api/active-record-mixin/#delete","title":"delete","text":"<pre><code>async def delete() -&gt; None\n</code></pre> <p>Delete the current row.</p> Danger <p>This is not a soft delete method. It will permanently delete the row from the database. So, if you want to keep the row in the database, you can implement a custom soft delete method, i.e. using <code>save()</code> method to update the row with a flag indicating if the row is deleted or not (i.e. a boolean <code>is_deleted</code> column).</p> <p>Raises</p> <ul> <li><code>SQLAlchemyError</code>: If deleting fails.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.find(username='Bob324').one_or_none()\n&gt;&gt;&gt; user.name\nBob Williams\n&gt;&gt;&gt; await user.delete()\n&gt;&gt;&gt; await User.find(username='Bob324').one_or_none()\nNone\n</code></pre>"},{"location":"api/active-record-mixin/#remove","title":"remove","text":"<pre><code>async def remove() -&gt; None\n</code></pre> <p>Synonym for <code>delete()</code>.</p>"},{"location":"api/active-record-mixin/#class-methods","title":"Class Methods","text":""},{"location":"api/active-record-mixin/#insert","title":"insert","text":"<pre><code>@classmethod\nasync def insert(**kwargs) -&gt; Self\n</code></pre> <p>Insert a new row and return the saved instance.</p> <p>Parameters</p> <ul> <li><code>kwargs</code>: Key-value pairs for the new instance.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The created instance for method chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.insert(name='Bob Williams', age=30)\n&gt;&gt;&gt; user.name\nBob Williams\n</code></pre>"},{"location":"api/active-record-mixin/#create","title":"create","text":"<pre><code>@classmethod\nasync def create(**kwargs) -&gt; Self\n</code></pre> <p>Synonym for <code>insert()</code>.</p>"},{"location":"api/active-record-mixin/#save_all","title":"save_all","text":"<pre><code>@classmethod\nasync def save_all(rows: Sequence[Self], refresh: bool = False) -&gt; None\n</code></pre> <p>Save multiple rows in a single transaction.</p> <p>When using this method to update existing rows, instances are not refreshed after commit by default. Accessing the attributes of the updated rows without refreshing them after commit will raise an <code>sqlalchemy.orm.exc.DetachedInstanceError</code>.</p> <p>To access the attributes of updated rows, the <code>refresh</code> flag must be set to <code>True</code> in order to refresh them after commit.</p> Warning <p>Refreshing multiple instances may be expensive, which may lead to a higher latency due to additional database queries.</p> Note <p>When inserting new rows, refreshing the instances after commit is no necessary. The instances are already available after commit, but you still can use the <code>refresh</code> flag to refresh them if needed.</p> <p>Parameters</p> <ul> <li><code>rows</code>: Sequence of rows to be saved.</li> <li><code>refresh</code>: Whether to refresh the rows after commit (default: <code>False</code>).</li> </ul> <p>Raises</p> <ul> <li><code>SQLAlchemyError</code>: If saving fails.</li> </ul> <p>Examples</p> <p>Inserting new rows: <pre><code>&gt;&gt;&gt; users = [\n...     User(name='Bob Williams', age=30),\n...     User(name='Jane Doe', age=31),\n...     User(name='John Doe', age=32),\n... ]\n&gt;&gt;&gt; await User.save_all(users)\n&gt;&gt;&gt; users[0].name\nBob Williams\n&gt;&gt;&gt; users[1].age\n31\n</code></pre></p> <p>Updating existing rows (with refreshing after commit): <pre><code>&gt;&gt;&gt; users = User.where(name__endswith='Doe').all()\n&gt;&gt;&gt; for user in users:\n...     user.name = user.name.replace('Doe', 'Smith')\n&gt;&gt;&gt; await User.save_all(users, refresh=True)\n&gt;&gt;&gt; users[0].name\nJane Smith\n&gt;&gt;&gt; users[1].name\nJohn Smith\n</code></pre></p> <p>Updating existing rows (without refreshing after commit): <pre><code>&gt;&gt;&gt; users = User.where(name__endswith='Doe').all()\n&gt;&gt;&gt; for user in users:\n...     user.name = user.name.replace('Doe', 'Smith')\n&gt;&gt;&gt; await User.save_all(users)\n&gt;&gt;&gt; users[0].name\nTraceback (most recent call last):\n    ...\nDetachedInstanceError: Instance &lt;User at 0x...&gt; is not bound to a Session...\n</code></pre></p>"},{"location":"api/active-record-mixin/#insert_all","title":"insert_all","text":"<pre><code>@classmethod\nasync def insert_all(rows: Sequence[Self], refresh: bool = False) -&gt; None\n</code></pre> <p>Insert multiple rows in a single transaction.</p> <p>This is mostly a shortcut for <code>save_all()</code> when inserting new rows.</p> Note <p>When inserting new rows, refreshing the instances after commit is not necessary. The instances are already available after commit, but you still can use the <code>refresh</code> flag to refresh them if needed.</p> <p>See the <code>save_all()</code> method for more details.</p>"},{"location":"api/active-record-mixin/#update_all","title":"update_all","text":"<pre><code>@classmethod\nasync def update_all(rows: Sequence[Self], refresh: bool = False) -&gt; None\n</code></pre> <p>Update multiple rows in a single transaction.</p> <p>This is mostly a shortcut for <code>save_all()</code> when updating existing rows.</p> <p>If you are planning to access the attributes of the updated instances after commit, you must set the <code>refresh</code> flag to <code>True</code> in order to refresh them. Accessing the attributes of the updated instances without refreshing them after commit will raise an <code>sqlalchemy.orm.exc.DetachedInstanceError</code>.</p> Warning <p>Refreshing multiple instances may be expensive, which may lead to a higher latency due to additional database queries.</p> <p>See the <code>save_all()</code> method for more details.</p>"},{"location":"api/active-record-mixin/#delete_all","title":"delete_all","text":"<pre><code>@classmethod\nasync def delete_all(rows: Sequence[Self]) -&gt; None\n</code></pre> <p>Delete multiple rows in a single transaction.</p> Danger <p>This is not a soft delete method. It will permanently delete the row from the database. So, if you want to keep the row in the database, you can implement a custom soft delete method, i.e. using <code>save()</code> method to update the row with a flag indicating if the row is deleted or not (i.e. a boolean <code>is_deleted</code> column).</p> <p>Parameters</p> <ul> <li><code>rows</code>: Sequence of rows to be deleted.</li> </ul> <p>Raises</p> <ul> <li><code>SQLAlchemyError</code>: If deleting fails.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; users = await User.where(name__endswith='Doe').all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2)]\n&gt;&gt;&gt; await User.delete_all(users)\n&gt;&gt;&gt; await User.where(name__endswith='Doe').all()\n[]\n</code></pre>"},{"location":"api/active-record-mixin/#destroy","title":"destroy","text":"<pre><code>@classmethod\nasync def destroy(*ids: object) -&gt; None\n</code></pre> <p>Delete multiple rows by their primary key.</p> <p>This method can only be used if the model has a single primary key. Otherwise, it will raise a <code>CompositePrimaryKeyError</code> exception.</p> Danger <p>This is not a soft delete method. It will permanently delete the row from the database. So, if you want to keep the row in the database, you can implement a custom soft delete method, i.e. using <code>save()</code> method to update the row with a flag indicating if the row is deleted or not (i.e. a boolean <code>is_deleted</code> column).</p> <p>Parameters</p> <ul> <li><code>ids</code>: Primary key values of rows to delete.</li> </ul> <p>Raises</p> <ul> <li><code>CompositePrimaryKeyError</code>: If the model has a composite primary key.</li> <li><code>SQLAlchemyError</code>: If deleting fails.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; users = await User.where(name__endswith='Doe').all()\n&gt;&gt;&gt; [user.id for user in users]\n[1, 2]\n&gt;&gt;&gt; await User.destroy(1, 2)\n&gt;&gt;&gt; await User.where(name__endswith='Doe').all()\n[]\n</code></pre>"},{"location":"api/active-record-mixin/#get","title":"get","text":"<pre><code>@classmethod\nasync def get(\n    pk: object,\n    join: Sequence[EagerLoadPath] | None = None,\n    subquery: Sequence[EagerLoadPath] | None = None,\n    schema: EagerSchema | None = None,\n) -&gt; Self | None\n</code></pre> <p>Fetch a row by primary key or return <code>None</code> if no result is found.</p> <p>If multiple results are found, it will raise a <code>sqlalchemy.exc.MultipleResultsFound</code> exception.</p> <p>Parameters</p> <ul> <li><code>pk</code>: Primary key value. It can also be a dict of composite primary key values.</li> <li><code>join</code>: Paths to join eager load. IMPORTANT See the docs of <code>join</code> method for details.</li> <li><code>subquery</code>: Paths to subquery eager load. IMPORTANT See the docs of <code>with_subquery</code> method for details.</li> <li><code>schema</code>: Schema for the eager loading. IMPORTANT See the docs of <code>with_schema</code> method for details.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance for method chaining if found.</li> <li><code>None</code>: If no result is found.</li> </ul> <p>Raises</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.get(1)\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await User.get(100)  # does not exist\n&gt;&gt;&gt; user\nNone\n</code></pre>"},{"location":"api/active-record-mixin/#get_or_fail","title":"get_or_fail","text":"<pre><code>@classmethod\nasync def get_or_fail(\n    pk: object,\n    join: Sequence[EagerLoadPath] | None = None,\n    subquery: Sequence[EagerLoadPath] | None = None,\n    schema: EagerSchema | None = None,\n) -&gt; Self\n</code></pre> <p>Fetch a row by primary key.</p> <p>If no result is found, it will raise a <code>sqlalchemy.exc.NoResultFound</code> exception.</p> <p>If multiple results are found, it will raise a <code>sqlalchemy.exc.MultipleResultsFound</code> exception.</p> <p>Parameters</p> <ul> <li><code>pk</code>: Primary key value. It can also be a dict of composite primary key values.</li> <li><code>join</code>: Paths to join eager load. IMPORTANT See the docs of <code>join</code> method for details.</li> <li><code>subquery</code>: Paths to subquery eager load. IMPORTANT See the docs of <code>with_subquery</code> method for details.</li> <li><code>schema</code>: Schema for the eager loading. IMPORTANT See the docs of <code>with_schema</code> method for details.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>NoResultFound</code>: If no result is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.get_or_fail(1)\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await User.get_or_fail(100)  # does not exist\nTraceback (most recent call last):\n    ...\nNoResultFound: User with id '100' was not found\n</code></pre>"},{"location":"api/active-record-mixin/#scalars","title":"scalars","text":"<pre><code>@classmethod\nasync def scalars() -&gt; ScalarResult[Self]\n</code></pre> <p>Fetch all rows as scalars.</p> <p>Returns</p> <ul> <li><code>sqlalchemy.engine.ScalarResult[Self]</code>: Result instance containing all scalars.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; result = await User.scalars()\n&gt;&gt;&gt; result\n&lt;sqlalchemy.engine.result.ScalarResult object at 0x...&gt;\n&gt;&gt;&gt; users = result.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; result = await User.where(name='John Doe').scalars()\n&gt;&gt;&gt; users = result.all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre>"},{"location":"api/active-record-mixin/#first","title":"first","text":"<pre><code>@classmethod\nasync def first(scalar: bool = True) -&gt; Self | Row[tuple[Any, ...]] | None\n</code></pre> <p>Fetch the first row or return <code>None</code> if no results are found.</p> <p>If <code>scalar</code> is <code>True</code>, returns a scalar value (default).</p> <p>Parameters</p> <ul> <li><code>scalar</code>: If <code>True</code>, returns a scalar value (<code>Self</code>), otherwise returns a row (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: Instance for method chaining (scalar).</li> <li><code>sqlalchemy.engine.Row[tuple[Any, ...]]</code>: Row.</li> <li><code>None</code>: If no result is found.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; user = await User.first()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await User.first(scalar=False)\n&gt;&gt;&gt; user\n(User(id=1),)\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; user = await User.select(User.name, User.age).first()\n&gt;&gt;&gt; user\nBob Williams\n&gt;&gt;&gt; user = await User.select(User.name, User.age).first(scalar=False)\n&gt;&gt;&gt; user\n('Bob Williams', 30)\n</code></pre></p>"},{"location":"api/active-record-mixin/#one","title":"one","text":"<pre><code>@classmethod\nasync def one(scalar: bool = True) -&gt; Self | Row[tuple[Any, ...]]\n</code></pre> <p>Fetch one row.</p> <p>If no result is found, it will raise a <code>sqlalchemy.exc.NoResultFound</code> exception.</p> <p>If multiple results are found, it will raise a <code>sqlalchemy.exc.MultipleResultsFound</code> exception.</p> <p>If <code>scalar</code> is <code>True</code>, returns a scalar value (default).</p> <p>Parameters</p> <ul> <li><code>scalar</code>: If <code>True</code>, returns a scalar value (<code>Self</code>), otherwise returns a row (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: Instance for method chaining (scalar).</li> <li><code>sqlalchemy.engine.Row[tuple[Any, ...]]</code>: Row.</li> </ul> <p>Raises</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; user = await User.where(name='John Doe').one()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await User.where(name='John Doe').one(scalar=False)\n&gt;&gt;&gt; user\n(User(id=1),)\n&gt;&gt;&gt; user = await User.where(name='Unknown').one()\nTraceback (most recent call last):\n    ...\nsqlalchemy.exc.NoResultFound: No row was found when one was required\n&gt;&gt;&gt; user = await User.one()\nTraceback (most recent call last):\n    ...\nsqlalchemy.exc.MultipleResultsFound: Multiple rows were found when one was required\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; user = await User.where(name='John Doe')\n...                  .select(User.name, User.age)\n...                  .one()\n&gt;&gt;&gt; user\nJohn Doe\n&gt;&gt;&gt; user = await User.where(name='John Doe')\n...                  .select(User.name, User.age)\n...                  .one(scalar=False)\n&gt;&gt;&gt; user\n('John Doe', 30)\n</code></pre></p>"},{"location":"api/active-record-mixin/#one_or_none","title":"one_or_none","text":"<pre><code>@classmethod\nasync def one_or_none(scalar: bool = True) -&gt; Self | Row[tuple[Any, ...]] | None\n</code></pre> <p>Fetch one row or return <code>None</code> if no results are found.</p> <p>If multiple results are found, it will raise a <code>sqlalchemy.exc.MultipleResultsFound</code> exception.</p> <p>If <code>scalar</code> is <code>True</code>, returns a scalar value (default).</p> <p>Parameters</p> <ul> <li><code>scalar</code>: If <code>True</code>, returns a scalar value (<code>Self</code>), otherwise returns a row (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: Instance for method chaining (scalar).</li> <li><code>sqlalchemy.engine.Row[tuple[Any, ...]]</code>: Row.</li> <li><code>None</code>: If no result is found.</li> </ul> <p>Raises</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; user = await User.where(name='John Doe').one_or_none()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await User.where(name='John Doe').one_or_none(scalar=False)\n&gt;&gt;&gt; user\n(User(id=1),)\n&gt;&gt;&gt; user = await User.where(name='Unknown').one_or_none()\n&gt;&gt;&gt; user\nNone\n&gt;&gt;&gt; user = await User.one_or_none()\nTraceback (most recent call last):\n    ...\nsqlalchemy.exc.MultipleResultsFound: Multiple rows were found when one was required\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; user = await User.where(name='John Doe')\n...                  .select(User.name, User.age)\n...                  .one_or_none()\n&gt;&gt;&gt; user\nJohn Doe\n&gt;&gt;&gt; user = await User.where(name='John Doe')\n...                  .select(User.name, User.age)\n...                  .one_or_none(scalar=False)\n&gt;&gt;&gt; user\n('John Doe', 30)\n</code></pre></p>"},{"location":"api/active-record-mixin/#all","title":"all","text":"<pre><code>@classmethod\nasync def all(scalars: bool = True) -&gt; Sequence[Self] | Sequence[Row[tuple[Any, ...]]]\n</code></pre> <p>Fetch all rows.</p> <p>If <code>scalars</code> is <code>True</code>, returns scalar values (default).</p> <p>Parameters</p> <ul> <li><code>scalars</code>: If <code>True</code>, returns scalar values (<code>Sequence[Self]</code>), otherwise returns rows (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Sequence[Self]</code>: Instances (scalars).</li> <li><code>Sequence[sqlalchemy.engine.Row[tuple[Any, ...]]]</code>: Rows.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; users = await User.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await User.all(scalars=False)\n&gt;&gt;&gt; users\n[(User(id=1),), (User(id=2),), ...]\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; users = await User.select(User.name, User.age).all()\n&gt;&gt;&gt; users\n[('John Doe', 30), ('Jane Doe', 25), ...]\n&gt;&gt;&gt; users = await User.select(User.name, User.age).all(scalars=False)\n&gt;&gt;&gt; users\n[(('John Doe', 30),), (('Jane Doe', 25),), ...]\n</code></pre></p>"},{"location":"api/active-record-mixin/#count","title":"count","text":"<pre><code>@classmethod\nasync def count() -&gt; int\n</code></pre> <p>Fetch the number of rows.</p> <p>Returns</p> <ul> <li><code>int</code>: Number of rows.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; count = await User.count()\n&gt;&gt;&gt; count\n34\n</code></pre>"},{"location":"api/active-record-mixin/#unique","title":"unique","text":"<pre><code>@classmethod\nasync def unique(scalars: bool = True) -&gt; ScalarResult[Self] | Result[tuple[Any, ...]]\n</code></pre> <p>Return rows with unique filtering applied.</p> <p>If <code>scalars</code> is <code>False</code>, returns a <code>sqlalchemy.engine.Result</code> instance instead of a <code>sqlalchemy.engine.ScalarResult</code> instance.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>Parameters</p> <ul> <li><code>scalars</code>: If <code>True</code>, returns a <code>sqlalchemy.engine.ScalarResult</code> instance. Otherwise, returns a <code>sqlalchemy.engine.Result</code> instance (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>sqlalchemy.engine.ScalarResult[Self]</code>: Result instance containing all scalars.</li> <li><code>sqlalchemy.engine.Result[tuple[Any, ...]]</code>: Result instance containing all rows.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; users = await User.unique()\n&gt;&gt;&gt; users\n&lt;sqlalchemy.engine.result.ScalarResult object at 0x...&gt;\n&gt;&gt;&gt; users = await User.unique(scalars=False)\n&gt;&gt;&gt; users\n&lt;sqlalchemy.engine.result.Result object at 0x...&gt;\n</code></pre>"},{"location":"api/active-record-mixin/#unique_first","title":"unique_first","text":"<pre><code>@classmethod\nasync def unique_first(scalar: bool = True) -&gt; Self | Row[tuple[Any, ...]] | None\n</code></pre> <p>Similar to <code>first()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>first()</code> for more details.</p>"},{"location":"api/active-record-mixin/#unique_one","title":"unique_one","text":"<pre><code>@classmethod\nasync def unique_one(scalar: bool = True) -&gt; Self | Row[tuple[Any, ...]]\n</code></pre> <p>Similar to <code>one()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>one()</code> for more details.</p>"},{"location":"api/active-record-mixin/#unique_one_or_none","title":"unique_one_or_none","text":"<pre><code>@classmethod\nasync def unique_one_or_none(scalar: bool = True) -&gt; Self | Row[tuple[Any, ...]] | None\n</code></pre> <p>Similar to <code>one_or_none()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>one_or_none()</code> for more details.</p>"},{"location":"api/active-record-mixin/#unique_all","title":"unique_all","text":"<pre><code>@classmethod\nasync def unique_all(scalars: bool = True) -&gt; Sequence[Self] | Sequence[Row[tuple[Any, ...]]]\n</code></pre> <p>Similar to <code>all()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>all()</code> for more details.</p>"},{"location":"api/active-record-mixin/#unique_count","title":"unique_count","text":"<pre><code>@classmethod\nasync def unique_count() -&gt; int\n</code></pre> <p>Similar to <code>count()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>count()</code> for more details.</p>"},{"location":"api/active-record-mixin/#select","title":"select","text":"<pre><code>@classmethod\ndef select(*entities: _ColumnsClauseArgument[Any]) -&gt; AsyncQuery[Self]\n</code></pre> <p>Replace the columns clause with the given entities.</p> <p>The existing set of FROMs are maintained, including those implied by the current columns clause.</p> <p>Parameters</p> <ul> <li><code>entities</code>: The entities to select.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; async_query = User.order_by('-created_at')\n&gt;&gt;&gt; async_query\nSELECT users.id, users.username, users.name, ... FROM users ORDER BY users.created_at DESC\n&gt;&gt;&gt; async_query.select(User.name, User.age)\n&gt;&gt;&gt; async_query\nSELECT users.name, users.age FROM users ORDER BY users.created_at DESC\n</code></pre>"},{"location":"api/active-record-mixin/#distinct","title":"distinct","text":"<pre><code>@classmethod\ndef distinct() -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply DISTINCT to the SELECT statement overall.</p> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.query\nSELECT users.id, users.username, users.name, ... FROM users\n&gt;&gt;&gt; User.distinct()\nSELECT DISTINCT users.id, users.username, users.name, ... FROM users\n</code></pre>"},{"location":"api/active-record-mixin/#options","title":"options","text":"<pre><code>@classmethod\ndef options(*args: ExecutableOption) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply the given list of mapper options.</p> Warning <p>Quoting from the joined eager loading docs:</p> <pre><code>When including `joinedload()` in reference to a one-to-many or\nmany-to-many collection, the `Result.unique()` method must be\napplied to the returned result, which will uniquify the incoming\nrows by primary key that otherwise are multiplied out by the join.\nThe ORM will raise an error if this is not present.\n\nThis is not automatic in modern SQLAlchemy, as it changes the behavior\nof the result set to return fewer ORM objects than the statement would\nnormally return in terms of number of rows. Therefore SQLAlchemy keeps\nthe use of `Result.unique()` explicit, so there is no ambiguity that\nthe returned objects are being uniquified on primary key.\n</code></pre> <p>This is, when fetching many rows and using joined eager loading, the <code>unique()</code> method or related (i.e. <code>unique_all()</code>) must be called to ensure that the rows are unique on primary key (see the examples below).</p> <p>To learn more about options, see the Query.options docs.</p> <p>Parameters</p> <ul> <li><code>args</code>: The options to apply.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <p>Joined eager loading: <pre><code>&gt;&gt;&gt; users = await User.options(joinedload(User.posts))\n...                   .unique_all()  # required for joinedload()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users[0].posts\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; user = await User.options(joinedload(User.posts)).first()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; users.posts\n[Post(id=1), Post(id=2), ...]\n</code></pre></p> <p>Subquery eager loading: <pre><code>&gt;&gt;&gt; users = await User.options(subqueryload(User.posts)).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users[0].posts\n[Post(id=1), Post(id=2), ...]\n</code></pre></p> <p>Eager loading without calling unique() before all(): <pre><code>&gt;&gt;&gt; users = await User.options(joinedload(User.posts)).all()\nTraceback (most recent call last):\n    ...\nInvalidRequestError: The unique() method must be invoked on this Result...\n</code></pre></p>"},{"location":"api/active-record-mixin/#where","title":"where","text":"<pre><code>@classmethod\ndef where(*criteria: ColumnElement[bool], **filters: Any) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply one or more WHERE criteria to the query.</p> <p>It supports both Django-like syntax and SQLAlchemy syntax.</p> <p>Parameters</p> <ul> <li><code>criteria</code>: SQLAlchemy style filter expressions.</li> <li><code>filters</code>: Django-style filters.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <p>Using Django-like syntax: <pre><code>&gt;&gt;&gt; users = await User.where(age__gte=18).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await User.where(name__like='%John%', age=30).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p> <p>Using SQLAlchemy syntax: <pre><code>&gt;&gt;&gt; users = await User.where(User.age &gt;= 18).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await User.where(User.name == 'John Doe', User.age == 30).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p> <p>Using both syntaxes: <pre><code>&gt;&gt;&gt; users = await User.where(User.age == 30, name__like='%John%').all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p>"},{"location":"api/active-record-mixin/#filter","title":"filter","text":"<pre><code>@classmethod\ndef filter(*criterion: ColumnElement[bool], **filters: Any) -&gt; AsyncQuery[Self]\n</code></pre> <p>Synonym for <code>where()</code>.</p>"},{"location":"api/active-record-mixin/#find","title":"find","text":"<pre><code>@classmethod\ndef find(*criterion: ColumnElement[bool], **filters: Any) -&gt; AsyncQuery[Self]\n</code></pre> <p>Synonym for <code>where()</code>.</p>"},{"location":"api/active-record-mixin/#search","title":"search","text":"<pre><code>@classmethod\ndef search(\n    search_term: str,\n    columns: Sequence[str | InstrumentedAttribute[Any]] | None = None,\n) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply a search filter to the query.</p> <p>Searches for <code>search_term</code> in the searchable columns of the model. If <code>columns</code> are provided, searches only these columns.</p> <p>Parameters</p> <ul> <li><code>search_term</code>: Search term.</li> <li><code>columns</code>: Columns to search in.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; users = await User.search(search_term='John').all()\n&gt;&gt;&gt; users\n[User(id=2), User(id=6)]\n&gt;&gt;&gt; users[0].name\nJohn Doe\n&gt;&gt;&gt; users[0].username\nJohn321\n&gt;&gt;&gt; users[1].name\nDiana Johnson\n&gt;&gt;&gt; users[1].username\nDiana84\n</code></pre></p> <p>Searching specific columns: <pre><code>&gt;&gt;&gt; users = await User.search(\n...     search_term='John',\n...     columns=[User.name, User.username]\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2), User(id=6)]\n&gt;&gt;&gt; users = await User.search(\n...     search_term='John',\n...     columns=[User.username]  # or 'username'\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p>"},{"location":"api/active-record-mixin/#order_by","title":"order_by","text":"<pre><code>@classmethod\ndef order_by(*columns: ColumnExpressionOrStrLabelArgument[Any]) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply one or more ORDER BY criteria to the query.</p> <p>It supports both Django-like syntax and SQLAlchemy syntax.</p> <p>Parameters</p> <ul> <li><code>columns</code>: Django-like or SQLAlchemy sort expressions.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <p>Using Django-like syntax: <pre><code>&gt;&gt;&gt; posts = await Post.order_by('-rating', 'user___name').all()\n&gt;&gt;&gt; posts\n[Post(id=1), Post(id=4), ...]\n</code></pre></p> <p>Using SQLAlchemy syntax: <pre><code>&gt;&gt;&gt; posts = await Post.order_by(Post.rating.desc()).all()\n&gt;&gt;&gt; posts\n[Post(id=1), Post(id=4), ...]\n</code></pre></p> <p>Using both syntaxes:</p> <pre><code>&gt;&gt;&gt; posts = await Post.order_by(\n...     Post.rating.desc(),\n...     'user___name'\n... ).all()\n&gt;&gt;&gt; posts\n[Post(id=1), Post(id=4), ...]\n</code></pre>"},{"location":"api/active-record-mixin/#sort","title":"sort","text":"<pre><code>@classmethod\ndef sort(*columns: ColumnExpressionOrStrLabelArgument[Any]) -&gt; AsyncQuery[Self]\n</code></pre> <p>Synonym for <code>order_by()</code>.</p>"},{"location":"api/active-record-mixin/#group_by","title":"group_by","text":"<pre><code>@classmethod\ndef group_by(\n    *columns: ColumnExpressionOrStrLabelArgument[Any],\n    select_columns: Sequence[_ColumnsClauseArgument[Any]] | None = None,\n) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply one or more GROUP BY criteria to the query.</p> <p>It supports both Django-like syntax and SQLAlchemy syntax.</p> <p>It is recommended to select specific columns. You can use the <code>select_columns</code> parameter to select specific columns.</p> <p>Parameters</p> <ul> <li><code>columns</code>: Django-like or SQLAlchemy columns.</li> <li><code>select_columns</code>: Columns to be selected (recommended).</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; from sqlalchemy.sql.functions import func\n&gt;&gt;&gt; columns = (User.age, func.count(User.name))\n&gt;&gt;&gt; async_query = User.group_by(\n...     User.age, select_columns=columns\n... )\n&gt;&gt;&gt; rows = await async_query.all(scalars=False)\n[(30, 2), (32, 1), ...]\n</code></pre></p> <p>You can also call <code>select()</code> before calling <code>group_by()</code>: <pre><code>&gt;&gt;&gt; from sqlalchemy.sql import text, func\n&gt;&gt;&gt; async_query = Post.select(\n...     Post.rating,\n...     text('users_1.name'),\n...     func.count(Post.title)\n... )\n&gt;&gt;&gt; async_query.group_by('rating', 'user___name')\n&gt;&gt;&gt; rows = async_query.all(scalars=False)\n&gt;&gt;&gt; rows\n[(4, 'John Doe', 1), (5, 'Jane Doe', 1), ...]\n</code></pre></p>"},{"location":"api/active-record-mixin/#offset","title":"offset","text":"<pre><code>@classmethod\ndef offset(offset: int) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply one OFFSET criteria to the query.</p> <p>Parameters</p> <ul> <li><code>offset</code>: Number of rows to skip.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Raises</p> <ul> <li><code>NegativeIntegerError</code>: If <code>offset</code> is negative.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; users = await User.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await User.offset(10).all()\n&gt;&gt;&gt; users\n[User(id=11), User(id=12), ...]\n&gt;&gt;&gt; User.offset(-1)\nTraceback (most recent call last):\n    ...\nNegativeIntegerError: offset must be &gt;= 0, got -1\n</code></pre></p>"},{"location":"api/active-record-mixin/#skip","title":"skip","text":"<pre><code>@classmethod\ndef skip(skip: int) -&gt; AsyncQuery[Self]\n</code></pre> <p>Synonym for <code>offset()</code>.</p>"},{"location":"api/active-record-mixin/#limit","title":"limit","text":"<pre><code>@classmethod\ndef limit(limit: int) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply one LIMIT criteria to the query.</p> <p>Parameters</p> <ul> <li><code>limit</code>: Maximum number of rows to return.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Raises</p> <ul> <li><code>NegativeIntegerError</code>: If <code>limit</code> is negative.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; users = await User.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await User.limit(2).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2)]\n&gt;&gt;&gt; User.limit(-1)\nTraceback (most recent call last):\n    ...\nNegativeIntegerError: limit must be &gt;= 0, got -1\n</code></pre>"},{"location":"api/active-record-mixin/#take","title":"take","text":"<pre><code>@classmethod\ndef take(take: int) -&gt; AsyncQuery[Self]\n</code></pre> <p>Synonym for <code>limit()</code>.</p>"},{"location":"api/active-record-mixin/#top","title":"top","text":"<pre><code>@classmethod\ndef top(top: int) -&gt; AsyncQuery[Self]\n</code></pre> <p>Synonym for <code>limit()</code>.</p>"},{"location":"api/active-record-mixin/#join","title":"join","text":"<pre><code>@classmethod\ndef join(*paths: EagerLoadPath) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply joined eager loading using LEFT OUTER JOIN.</p> <p>When a tuple is passed, the second element must be boolean, and if <code>True</code>, the join is <code>INNER JOIN</code>, otherwise <code>LEFT OUTER JOIN</code>.</p> Note <p>Only direct relationships can be loaded.</p> <p>Parameters</p> <ul> <li><code>paths</code>: Relationship attributes to join.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Raises</p> <ul> <li><code>ValueError</code>: If the second element of tuple is not boolean.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; comment = await Comment.join(\n...     Comment.user,         # LEFT OUTER JOIN\n...     (Comment.post, True)  # True = INNER JOIN\n... ).first()\n&gt;&gt;&gt; comment\nComment(id=1)\n&gt;&gt;&gt; comment.user\nUser(id=1)\n&gt;&gt;&gt; comment.post\nPost(id=1)\n&gt;&gt;&gt; Comment.join(\n...     Comment.user,\n...     (Comment.post, 'inner')  # invalid argument\n... )\nTraceback (most recent call last):\n    ...\nValueError: expected boolean for second element of tuple, got str: 'inner'\n</code></pre></p>"},{"location":"api/active-record-mixin/#with_subquery","title":"with_subquery","text":"<pre><code>@classmethod\ndef with_subquery(*paths: EagerLoadPath) -&gt; AsyncQuery[Self]\n</code></pre> <p>Subqueryload or Selectinload eager loading.</p> <p>Emits a second SELECT statement (Subqueryload) for each relationship to be loaded, across all result objects at once.</p> <p>When a tuple is passed, the second element must be boolean. If it is <code>True</code>, the eager loading strategy is SELECT IN (Selectinload), otherwise SELECT JOIN (Subqueryload).</p> Warning <p>A query which makes use of <code>subqueryload()</code> in conjunction with a limiting modifier such as <code>Query.limit()</code> or <code>Query.offset()</code> should always include <code>Query.order_by()</code> against unique column(s) such as the primary key, so that the additional queries emitted by <code>subqueryload()</code> include the same ordering as used by the parent query. Without it, there is a chance that the inner query could return the wrong rows, as specified in The importance of ordering.</p> <p>Incorrect, LIMIT without ORDER BY: <pre><code>User.options(subqueryload(User.posts)).first()\n</code></pre></p> <p>Incorrect if User.name is not unique: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name).first()\n</code></pre></p> <p>Correct: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name, User.id).first()\n</code></pre></p> <p>To get more information about SELECT IN and SELECT JOIN strategies, , see the <code>loading relationships docs</code>.</p> Note <p>Only direct relationships can be loaded.</p> <p>Parameters</p> <ul> <li><code>paths</code>: Relationship attributes to load.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Raises</p> <ul> <li><code>ValueError</code>: If the second element of tuple is not boolean.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; users = await User.with_subquery(\n...     User.posts,            # SELECT JOIN\n...     (User.comments, True)  # True = SELECT IN\n... ).all()\n&gt;&gt;&gt; users[0]\nUser(id=1)\n&gt;&gt;&gt; users[0].posts              # loaded using SELECT JOIN\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; users[0].posts[0].comments  # loaded using SELECT IN\n[Comment(id=1), Comment(id=2), ...]\n&gt;&gt;&gt; User.with_subquery(\n...     User.posts,\n...     (User.comments, 'selectin')  # invalid argument\n... )\nTraceback (most recent call last):\n    ...\nValueError: expected boolean for second element of tuple, got str: 'selectin'\n</code></pre></p> <p>Using a limiting modifier: <pre><code>&gt;&gt;&gt; user = await User.with_subquery(\n...     User.posts,            # SELECT JOIN\n...     (User.comments, True)  # True = SELECT IN\n... ).sort('id')  # sorting modifier (Important!!!)\n...  .first()     # limiting modifier\n&gt;&gt;&gt; user = await User.with_subquery(\n...     User.posts,            # SELECT JOIN\n...     (User.comments, True)  # True = SELECT IN\n... ).limit(1)    # limiting modifier\n...  .sort('id')  # sorting modifier (Important!!!)\n...  .all()[0]\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user.posts              # loaded using SELECT JOIN\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; user.posts[0].comments  # loaded using SELECT IN\n[Comment(id=1), Comment(id=2), ...]\n</code></pre></p>"},{"location":"api/active-record-mixin/#with_schema","title":"with_schema","text":"<pre><code>@classmethod\ndef with_schema(schema: EagerSchema) -&gt; AsyncQuery[Self]\n</code></pre> <p>Apply joined, subqueryload and selectinload eager loading.</p> <p>Useful for complex cases where you need to load nested relationships in separate queries.</p> Warning <p>A query which makes use of <code>subqueryload()</code> in conjunction with a limiting modifier such as <code>Query.limit()</code> or <code>Query.offset()</code> should always include <code>Query.order_by()</code> against unique column(s) such as the primary key, so that the additional queries emitted by <code>subqueryload()</code> include the same ordering as used by the parent query. Without it, there is a chance that the inner query could return the wrong rows, as specified in The importance of ordering.</p> <p>Incorrect, LIMIT without ORDER BY: <pre><code>User.options(subqueryload(User.posts)).first()\n</code></pre></p> <p>Incorrect if User.name is not unique: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name).first()\n</code></pre></p> <p>Correct: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name, User.id).first()\n</code></pre></p> <p>To get more information about SELECT IN and SELECT JOIN strategies, , see the <code>loading relationships docs</code>.</p> <p>Parameters</p> <ul> <li><code>schema</code>: Dictionary defining the loading strategy.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <pre><code>&gt;&gt;&gt; from sqlactive import JOINED, SUBQUERY\n&gt;&gt;&gt; schema = {\n...     User.posts: JOINED,          # joinedload user\n...     User.comments: (SUBQUERY, {  # load comments in separate query\n...         Comment.user: JOINED     # but, in this separate query, join user\n...     })\n... }\n&gt;&gt;&gt; user = await User.with_schema(schema)\n...                  .order_by(User.id)  # important when limiting\n...                  .first()            # limiting modifier\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user.posts\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; user.posts[0].comments\n[Comment(id=1), Comment(id=2), ...]\n&gt;&gt;&gt; user.posts[0].comments[0].user\nUser(id=1)\n</code></pre>"},{"location":"api/active-record-mixin/#smart_query","title":"smart_query","text":"<pre><code>@classmethod\ndef smart_query(\n    criteria: Sequence[ColumnElement[bool]] | None = None,\n    filters: DjangoFilters | None = None,\n    sort_columns: Sequence[ColumnExpressionOrStrLabelArgument[Any]] | None = None,\n    sort_attrs: Sequence[str] | None = None,\n    group_columns: Sequence[ColumnExpressionOrStrLabelArgument[Any]] | None = None,\n    group_attrs: Sequence[str] | None = None,\n    schema: EagerSchema | None = None,\n) -&gt; AsyncQuery[Self]\n</code></pre> <p>Create an async smart query.</p> <p>Smart queries combine filtering, sorting, grouping and eager loading.</p> <p>See <code>smart_query() from SmartQueryMixin</code> for details.</p>"},{"location":"api/active-record-mixin/#get_async_query","title":"get_async_query","text":"<pre><code>@classmethod\ndef get_async_query(query: Query | None = None) -&gt; AsyncQuery[Self]\n</code></pre> <p>Create an <code>AsyncQuery</code> instance.</p> <p>If no <code>sqlalchemy.sql.Select</code> instance is provided, it uses the <code>query</code> property of the model.</p> <p>Parameters</p> <ul> <li><code>query</code>: SQLAlchemy query.</li> </ul> <p>Returns</p> <ul> <li><code>AsyncQuery[Self]</code>: Async query instance for chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; async_query = User.get_async_query()\n&gt;&gt;&gt; bob = await async_query.where(name__like='Bob%').first()\n&gt;&gt;&gt; bob.name\nBob Williams\n&gt;&gt;&gt; bob.age\n30\n</code></pre>"},{"location":"api/active-record-mixin/#get_primary_key_name","title":"get_primary_key_name","text":"<pre><code>@classmethod\ndef get_primary_key_name() -&gt; str\n</code></pre> <p>Deprecated</p> <p>This function is deprecated since version 0.2 and will be removed in future versions. Use <code>primary_key_name</code> property instead.</p> <p>Get the primary key name of the model.</p> Warning <p>This method can only be used if the model has a single primary key. If the model has a composite primary key, an <code>CompositePrimaryKeyError</code> is raised.</p> <p>Returns</p> <ul> <li><code>str</code>: The name of the primary key.</li> </ul> <p>Raises</p> <ul> <li><code>CompositePrimaryKeyError</code>: If the model has a composite primary key.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.get_primary_key_name()\nid\n</code></pre>"},{"location":"api/active-record-mixin/#important-notes","title":"Important Notes","text":"<ol> <li> <p>When using <code>subqueryload()</code> with limiting modifiers (<code>limit()</code>, <code>offset()</code>),    always include <code>order_by()</code> with unique columns (like primary key) to ensure    correct results.</p> </li> <li> <p>For joined eager loading with one-to-many or many-to-many relationships,    use the <code>unique()</code> method or related (i.e. <code>unique_all()</code>)    to prevent duplicate rows:    <pre><code>users = await User.options(joinedload(User.posts)).unique_all()\n</code></pre></p> </li> </ol>"},{"location":"api/async-query/","title":"Async Query","text":"<p>The <code>AsyncQuery</code> class is an Async wrapper for <code>sqlalchemy.sql.Select</code>.</p> <p>It implements the functionality of both <code>Session</code> and <code>Smart Queries</code> mixins.</p> Warning <p>All relations used in filtering/sorting/grouping should be explicitly set, not just being a <code>backref</code>. See the About Relationships section for more information.</p> Info <p>The examples below assume the following models:</p> <pre><code>from sqlalchemy import ForeignKey, String\nfrom sqlalchemy.ext.hybrid import hybrid_method, hybrid_property\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom sqlactive.base_model import ActiveRecordBaseModel\n\n\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    username: Mapped[str] = mapped_column(\n        String(18), nullable=False, unique=True\n    )\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\n    @hybrid_property\n    def is_adult(self) -&gt; int:\n        return self.age &gt; 18\n\n    @hybrid_method\n    def older_than(self, other: 'User') -&gt; bool:\n        return self.age &gt; other.age\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n\n\nclass Product(BaseModel):\n    __tablename__ = 'products'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    description: Mapped[str] = mapped_column(String(100), nullable=False)\n    price: Mapped[float] = mapped_column(nullable=False)\n\n    sells: Mapped[list['Sell']] = relationship(\n        back_populates='product', viewonly=True\n    )\n\n\nclass Sell(BaseModel):\n    __tablename__ = 'sells'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    product_id: Mapped[int] = mapped_column(\n        ForeignKey('products.id'), primary_key=True\n    )\n    quantity: Mapped[int] = mapped_column(nullable=False)\n\n    product: Mapped['Product'] = relationship(back_populates='sells')\n</code></pre>"},{"location":"api/async-query/#usage","title":"Usage","text":"<p>The <code>AsyncQuery</code> class provides a set of helper methods for asynchronously executing the query.</p>"},{"location":"api/async-query/#setting-the-session","title":"Setting the Session","text":"<p>This class needs an <code>sqlalchemy.ext.asyncio.async_scoped_session</code> instance to perform the actual query. The <code>set_session</code> class method must be called before using this class.</p> <p>When calling the <code>set_session</code> method from a base model (either <code>ActiveRecordBaseModel</code>, a subclass of it or a model, i.e. <code>User</code>), the session will be set automatically.</p> <p>Calling <code>set_session</code> from either a base model or a model:</p> <pre><code># from your base model class (recommended)\nYourBaseModel.set_session(session)\n\n# from the ActiveRecordBaseModel class\nActiveRecordBaseModel.set_session(session)\n\n# from your model\nUser.set_session(session)\n\n# create a instance\nquery = select(User)\nasync_query = AsyncQuery(query)\n</code></pre> <p>Calling <code>set_session</code> from the <code>AsyncQuery</code> instance:</p> <pre><code># create a instance\nquery = select(User)\nasync_query = AsyncQuery(query)\n\n# set the session from the base model\nasync_query.set_session(BaseModel._session)\n\n# set the session from the model\nasync_query.set_session(User._session)\n</code></pre>"},{"location":"api/async-query/#performing-queries","title":"Performing Queries","text":"<p>Example of usage:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\nasync_query = async_query.where(name__like='%John%').sort('-created_at')\nasync_query = async_query.limit(2)\nusers = await async_query.all()\n</code></pre> <p>To get the <code>sqlalchemy.sql.Select</code> instance to use native SQLAlchemy methods use the <code>query</code> property:</p> <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\nasync_query.query  # &lt;sqlalchemy.sql.Select at 0x...&gt;\n</code></pre> Warning <p>If a <code>NoSessionError</code> is raised, it means that there is no session associated with the <code>AsyncQuery</code> instance. This can happen if the <code>set_session</code> method of the base model has not been called or if the model has not been initialized with a session.</p> <p>In this case, you must provide a session by calling the <code>set_session</code> either from the model or the <code>AsyncQuery</code> instance as described above.</p>"},{"location":"api/async-query/#api-reference","title":"API Reference","text":""},{"location":"api/async-query/#attributes","title":"Attributes","text":""},{"location":"api/async-query/#query","title":"query","text":"<pre><code>query: Query\n</code></pre> <p>The wrapped <code>sqlalchemy.sql.Select</code> instance.</p> <p>Examples <pre><code>query = select(User)\nasync_query = AsyncQuery(query)\nasync_query.query\n# &lt;sqlalchemy.sql.Select at 0x...&gt;\n\nasync_query.query = async_query.query.limit(10).order_by(User.age.desc())\nusers = await async_query.all()\n</code></pre></p>"},{"location":"api/async-query/#instance-methods","title":"Instance Methods","text":""},{"location":"api/async-query/#execute","title":"execute","text":"<pre><code>async def execute() -&gt; Result[Any]\n</code></pre> <p>Execute the query.</p> <p>Returns</p> <ul> <li><code>sqlalchemy.engine.Result[Any]</code>: Result of the query.</li> </ul>"},{"location":"api/async-query/#scalars","title":"scalars","text":"<pre><code>async def scalars() -&gt; ScalarResult[T]\n</code></pre> <p>Execute the query and return the result as scalars.</p> <p>Returns</p> <ul> <li><code>sqlalchemy.engine.ScalarResult[T]</code>: Result instance containing all scalars.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; result = await async_query.scalars()\n&gt;&gt;&gt; result\n&lt;sqlalchemy.engine.result.ScalarResult object at 0x...&gt;\n&gt;&gt;&gt; users = result.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; result = await async_query.where(name='John Doe').scalars()\n&gt;&gt;&gt; users = result.all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre>"},{"location":"api/async-query/#first","title":"first","text":"<pre><code>async def first(scalar: bool = True) -&gt; T | Row[tuple[Any, ...]] | None\n</code></pre> <p>Fetch the first row or <code>None</code> if no results are found.</p> <p>If <code>scalar</code> is <code>True</code>, returns a scalar value (default).</p> <p>Parameters</p> <ul> <li><code>scalar</code>: If <code>True</code>, returns a scalar value (<code>T</code>), otherwise returns a row (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>T</code>: Instance for method chaining (scalar).</li> <li><code>sqlalchemy.engine.Row[tuple[Any, ...]]</code>: Row.</li> <li><code>None</code>: If no result is found.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; user = await async_query.first()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await async_query.first(scalar=False)\n&gt;&gt;&gt; user\n(User(id=1),)\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; user = await async_query.select(User.name, User.age).first()\n&gt;&gt;&gt; user\nBob Williams\n&gt;&gt;&gt; user = await async_query.select(User.name, User.age)\n...                         .first(scalar=False)\n&gt;&gt;&gt; user\n('Bob Williams', 30)\n</code></pre></p>"},{"location":"api/async-query/#one","title":"one","text":"<pre><code>async def one(scalar: bool = True) -&gt; T | Row[tuple[Any, ...]]\n</code></pre> <p>Fetch one row or raise an exception if no results are found.</p> <p>If multiple results are found, it will raise a <code>sqlalchemy.exc.MultipleResultsFound</code> exception.</p> <p>If <code>scalar</code> is <code>True</code>, returns a scalar value (default).</p> <p>Parameters</p> <ul> <li><code>scalar</code>: If <code>True</code>, returns a scalar value (<code>T</code>), otherwise returns a row (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>T</code>: Instance for method chaining (scalar).</li> <li><code>sqlalchemy.engine.Row[tuple[Any, ...]]</code>: Row.</li> </ul> <p>Raises</p> <ul> <li><code>NoResultFound</code>: If no row is found.</li> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; user = await async_query.where(name='John Doe').one()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                         .one(scalar=False)\n&gt;&gt;&gt; user\n(User(id=1),)\n&gt;&gt;&gt; user = await async_query.where(name='Unknown').one()\nTraceback (most recent call last):\n    ...\nsqlalchemy.exc.NoResultFound: No row was found when one was required\n&gt;&gt;&gt; user = await async_query.one()\nTraceback (most recent call last):\n    ...\nsqlalchemy.exc.MultipleResultsFound: Multiple rows were found when one was required\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                  .select(User.name, User.age)\n...                  .one()\n&gt;&gt;&gt; user\nJohn Doe\n&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                  .select(User.name, User.age)\n...                  .one(scalar=False)\n&gt;&gt;&gt; user\n('John Doe', 30)\n</code></pre></p>"},{"location":"api/async-query/#one_or_none","title":"one_or_none","text":"<pre><code>async def one_or_none(scalar: bool = True) -&gt; T | Row[tuple[Any, ...]] | None\n</code></pre> <p>Fetch one row or <code>None</code> if no results are found.</p> <p>If multiple results are found, it will raise a <code>sqlalchemy.exc.MultipleResultsFound</code> exception.</p> <p>If <code>scalar</code> is <code>True</code>, returns a scalar value (default).</p> <p>Parameters</p> <ul> <li><code>scalar</code>: If <code>True</code>, returns a scalar value (<code>T</code>), otherwise returns a row (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>T</code>: Instance for method chaining (scalar).</li> <li><code>sqlalchemy.engine.Row[tuple[Any, ...]]</code>: Row.</li> <li><code>None</code>: If no result is found.</li> </ul> <p>Raises</p> <ul> <li><code>MultipleResultsFound</code>: If multiple rows match.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                         .one_or_none()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                         .one_or_none(scalar=False)\n&gt;&gt;&gt; user\n(User(id=1),)\n&gt;&gt;&gt; user = await async_query.where(name='Unknown')\n...                         .one_or_none()\n&gt;&gt;&gt; user\nNone\n&gt;&gt;&gt; user = await async_query.one_or_none()\nTraceback (most recent call last):\n    ...\nsqlalchemy.exc.MultipleResultsFound: Multiple rows were found when one was required\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                         .select(User.name, User.age)\n...                         .one_or_none()\n&gt;&gt;&gt; user\nJohn Doe\n&gt;&gt;&gt; user = await async_query.where(name='John Doe')\n...                         .select(User.name, User.age)\n...                         .one_or_none(scalar=False)\n&gt;&gt;&gt; user\n('John Doe', 30)\n</code></pre></p>"},{"location":"api/async-query/#all","title":"all","text":"<pre><code>async def all(scalars: bool = True) -&gt; Sequence[T] | Sequence[Row[tuple[Any, ...]]]\n</code></pre> <p>Fetch all rows.</p> <p>If <code>scalars</code> is <code>True</code>, returns scalar values (default).</p> <p>Parameters</p> <ul> <li><code>scalars</code>: If <code>True</code>, returns scalar values (<code>Sequence[T]</code>), otherwise returns rows (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Sequence[T]</code>: Instances (scalars).</li> <li><code>Sequence[sqlalchemy.engine.Row[tuple[Any, ...]]]</code>: Rows.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await async_query.all(scalars=False)\n&gt;&gt;&gt; users\n[(User(id=1),), (User(id=2),), ...]\n</code></pre></p> <p>Selecting specific columns: <pre><code>&gt;&gt;&gt; users = await async_query.select(User.name, User.age).all()\n&gt;&gt;&gt; users\n['John Doe', 'Jane Doe', ...]\n&gt;&gt;&gt; users = await async_query.select(User.name, User.age)\n...                          .all(scalars=False)\n&gt;&gt;&gt; users\n[('John Doe', 30), ('Jane Doe', 32), ...]\n</code></pre></p>"},{"location":"api/async-query/#count","title":"count","text":"<pre><code>async def count() -&gt; int\n</code></pre> <p>Fetch the number of rows.</p> <p>Returns</p> <ul> <li><code>int</code>: The number of rows.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; count = await async_query.count()\n&gt;&gt;&gt; count\n34\n</code></pre>"},{"location":"api/async-query/#unique","title":"unique","text":"<pre><code>async def unique(scalars: bool = True) -&gt; ScalarResult[T] | Result[tuple[Any, ...]]\n</code></pre> <p>Apply unique filtering to the result of the query.</p> <p>If <code>scalars</code> is <code>False</code>, returns a <code>sqlalchemy.engine.Result</code> instance instead of a <code>sqlalchemy.engine.ScalarResult</code> instance.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>Parameters</p> <ul> <li><code>scalars</code>: If <code>True</code>, returns a <code>sqlalchemy.engine.ScalarResult</code> instance. Otherwise, returns a <code>sqlalchemy.engine.Result</code> instance (default: <code>True</code>).</li> </ul> <p>Returns</p> <ul> <li><code>sqlalchemy.engine.ScalarResult[T]</code>: Result instance containing all scalars.</li> <li><code>sqlalchemy.engine.Result[tuple[Any, ...]]</code>: Result instance containing all rows.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.unique()\n&gt;&gt;&gt; users\n&lt;sqlalchemy.engine.result.ScalarResult object at 0x...&gt;\n&gt;&gt;&gt; users = await async_query.unique(scalars=False)\n&gt;&gt;&gt; users\n&lt;sqlalchemy.engine.result.Result object at 0x...&gt;\n</code></pre>"},{"location":"api/async-query/#unique_first","title":"unique_first","text":"<pre><code>async def unique_first(scalar: bool = True) -&gt; T | Row[tuple[Any, ...]] | None\n</code></pre> <p>Similar to <code>first()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>first()</code> for more details.</p>"},{"location":"api/async-query/#unique_one","title":"unique_one","text":"<pre><code>async def unique_one(scalar: bool) -&gt; T | Row[tuple[Any, ...]]\n</code></pre> <p>Similar to <code>one()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>one()</code> for more details.</p>"},{"location":"api/async-query/#unique_one_or_none","title":"unique_one_or_none","text":"<pre><code>async def unique_one_or_none(scalar: bool) -&gt; T | Row[tuple[Any, ...]] | None\n</code></pre> <p>Similar to <code>one_or_none()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>one_or_none()</code> for more details.</p>"},{"location":"api/async-query/#unique_all","title":"unique_all","text":"<pre><code>async def unique_all(scalars: bool) -&gt; Sequence[T] | Sequence[Row[tuple[Any, ...]]]\n</code></pre> <p>Similar to <code>all()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>all()</code> for more details.</p>"},{"location":"api/async-query/#unique_count","title":"unique_count","text":"<pre><code>async def unique_count() -&gt; int\n</code></pre> <p>Similar to <code>count()</code> with unique filtering applied.</p> Note <p>This method is different from <code>distinct()</code> in that it applies unique filtering to the objects returned in the result instance. If you need to apply unique filtering on the query (a DISTINCT clause), use <code>distinct()</code> instead.</p> <p>See <code>unique()</code> and <code>count()</code> for more details.</p>"},{"location":"api/async-query/#select","title":"select","text":"<pre><code>def select(*entities: _ColumnsClauseArgument[Any]) -&gt; Self\n</code></pre> <p>Replace the columns clause with the given entities.</p> <p>The existing set of FROMs are maintained, including those implied by the current columns clause.</p> <p>Parameters</p> <ul> <li><code>entities</code>: The entities to select.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; async_query.order_by('-created_at')\n&gt;&gt;&gt; async_query\nSELECT users.id, users.username, users.name, ... FROM users ORDER BY users.created_at DESC\n&gt;&gt;&gt; async_query.select(User.name, User.age)\n&gt;&gt;&gt; async_query\nSELECT users.name, users.age FROM users ORDER BY users.created_at DESC\n</code></pre>"},{"location":"api/async-query/#distinct","title":"distinct","text":"<pre><code>def distinct() -&gt; Self\n</code></pre> <p>Apply DISTINCT to the SELECT statement overall.</p> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; async_query.query\nSELECT users.id, users.username, users.name, ... FROM users\n&gt;&gt;&gt; async_query.distinct()\nSELECT DISTINCT users.id, users.username, users.name, ... FROM users\n</code></pre>"},{"location":"api/async-query/#options","title":"options","text":"<pre><code>def options(*args: ExecutableOption) -&gt; Self\n</code></pre> <p>Apply the given list of mapper options.</p> Warning <p>Quoting from the joined eager loading docs:</p> <pre><code>When including `joinedload()` in reference to a one-to-many or\nmany-to-many collection, the `Result.unique()` method must be\napplied to the returned result, which will uniquify the incoming\nrows by primary key that otherwise are multiplied out by the join.\nThe ORM will raise an error if this is not present.\n\nThis is not automatic in modern SQLAlchemy, as it changes the behavior\nof the result set to return fewer ORM objects than the statement would\nnormally return in terms of number of rows. Therefore SQLAlchemy keeps\nthe use of `Result.unique()` explicit, so there is no ambiguity that\nthe returned objects are being uniquified on primary key.\n</code></pre> <p>This is, when fetching many rows and using joined eager loading, the <code>unique()</code> method or related (i.e. <code>unique_all()</code>) must be called to ensure that the rows are unique on primary key (see the examples below).</p> <p>To learn more about options, see the Query.options docs.</p> <p>Parameters</p> <ul> <li><code>args</code>: The options to apply.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <p>Joined eager loading: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; aq = AsyncQuery(query)\n&gt;&gt;&gt; users = await aq.options(joinedload(User.posts))\n...                 .unique_all()  # required for joinedload()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users[0].posts\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; user = await aq.options(joinedload(User.posts)).first()\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; users.posts\n[Post(id=1), Post(id=2), ...]\n</code></pre></p> <p>Subquery eager loading: <pre><code>&gt;&gt;&gt; users = await aq.options(subqueryload(User.posts)).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users[0].posts\n[Post(id=1), Post(id=2), ...]\n</code></pre></p> <p>Eager loading without calling unique() before all(): <pre><code>&gt;&gt;&gt; users = await aq.options(joinedload(User.posts)).all()\nTraceback (most recent call last):\n    ...\nInvalidRequestError: The unique() method must be invoked on this Result...\n</code></pre></p>"},{"location":"api/async-query/#where","title":"where","text":"<pre><code>def where(*criteria: ColumnElement[bool], **filters: Any) -&gt; Self\n</code></pre> <p>Apply one or more WHERE criteria to the query.</p> <p>It supports both Django-like syntax and SQLAlchemy syntax.</p> <p>Parameters</p> <ul> <li><code>criteria</code>: SQLAlchemy style filter expressions.</li> <li><code>filters</code>: Django-style filters.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <p>Using Django-like syntax: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.where(age__gte=18).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await async_query.where(\n...     name__like='%John%',\n...     age=30\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p> <p>Using SQLAlchemy syntax: <pre><code>&gt;&gt;&gt; users = await async_query.where(User.age &gt;= 18).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await async_query.where(\n...     User.name == 'John Doe',\n...     User.age == 30\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p> <p>Using both syntaxes: <pre><code>&gt;&gt;&gt; users = await async_query.where(\n...     User.age == 30,\n...     name__like='%John%'\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p>"},{"location":"api/async-query/#filter","title":"filter","text":"<pre><code>def filter(*criterion: ColumnElement[bool], **filters: Any) -&gt; Self\n</code></pre> <p>Synonym for <code>where()</code>.</p>"},{"location":"api/async-query/#find","title":"find","text":"<pre><code>def find(*criterion: ColumnElement[bool], **filters: Any) -&gt; Self\n</code></pre> <p>Synonym for <code>where()</code>.</p>"},{"location":"api/async-query/#search","title":"search","text":"<pre><code>def search(\n    search_term: str,\n    columns: Sequence[str | InstrumentedAttribute[Any]] | None = None,\n) -&gt; Self\n</code></pre> <p>Apply a search filter to the query.</p> <p>Searches for <code>search_term</code> in the searchable columns of the model. If <code>columns</code> are provided, searches only these columns.</p> <p>Parameters</p> <ul> <li><code>search_term</code>: Search term.</li> <li><code>columns</code>: Columns to search in.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.search(search_term='John').all()\n&gt;&gt;&gt; users\n[User(id=2), User(id=6)]\n&gt;&gt;&gt; users[0].name\nJohn Doe\n&gt;&gt;&gt; users[0].username\nJohn321\n&gt;&gt;&gt; users[1].name\nDiana Johnson\n&gt;&gt;&gt; users[1].username\nDiana84\n</code></pre></p> <p>Searching specific columns: <pre><code>&gt;&gt;&gt; users = await async_query.search(\n...     search_term='John',\n...     columns=[User.name, User.username]\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2), User(id=6)]\n&gt;&gt;&gt; users = await async_query.search(\n...     search_term='John',\n...     columns=[User.username]  # or 'username'\n... ).all()\n&gt;&gt;&gt; users\n[User(id=2)]\n</code></pre></p>"},{"location":"api/async-query/#order_by","title":"order_by","text":"<pre><code>def order_by(*columns: ColumnExpressionOrStrLabelArgument) -&gt; Self\n</code></pre> <p>Apply one or more ORDER BY criteria to the query.</p> <p>It supports both Django-like syntax and SQLAlchemy syntax.</p> <p>Parameters</p> <ul> <li><code>columns</code>: Django-like or SQLAlchemy sort expressions.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <p>Using Django-like syntax: <pre><code>&gt;&gt;&gt; query = select(Post)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; posts = await async_query.order_by('-rating', 'user___name').all()\n&gt;&gt;&gt; posts\n[Post(id=1), Post(id=4), ...]\n</code></pre></p> <p>Using SQLAlchemy syntax: <pre><code>&gt;&gt;&gt; posts = await async_query.order_by(Post.rating.desc()).all()\n&gt;&gt;&gt; posts\n[Post(id=1), Post(id=4), ...]\n</code></pre></p> <p>Using both syntaxes:</p> <pre><code>&gt;&gt;&gt; posts = await async_query.order_by(\n...     Post.rating.desc(),\n...     'user___name'\n... ).all()\n&gt;&gt;&gt; posts\n[Post(id=1), Post(id=4), ...]\n</code></pre>"},{"location":"api/async-query/#sort","title":"sort","text":"<pre><code>def sort(*columns: ColumnExpressionOrStrLabelArgument) -&gt; Self\n</code></pre> <p>Synonym for <code>order_by()</code>.</p>"},{"location":"api/async-query/#group_by","title":"group_by","text":"<pre><code>def group_by(\n    *columns: ColumnExpressionOrStrLabelArgument,\n    select_columns: Sequence[_ColumnsClauseArgument[Any]] | None = None,\n) -&gt; Self\n</code></pre> <p>Apply one or more GROUP BY criteria to the query.</p> <p>It supports both Django-like syntax and SQLAlchemy syntax.</p> <p>It is recommended to select specific columns. You can use the <code>select_columns</code> parameter to select specific columns.</p> <p>Parameters</p> <ul> <li><code>columns</code>: Django-like or SQLAlchemy columns.</li> <li><code>select_columns</code>: Columns to be selected (recommended).</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; from sqlalchemy.sql.functions import func\n&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; columns = (User.age, func.count(User.name))\n&gt;&gt;&gt; async_query.group_by(\n...     User.age, select_columns=columns\n... )\n&gt;&gt;&gt; rows = await async_query.all(scalars=False)\n[(30, 2), (32, 1), ...]\n</code></pre></p> <p>You can also call <code>select()</code> before calling <code>group_by()</code>: <pre><code>&gt;&gt;&gt; from sqlalchemy.sql import text, func\n&gt;&gt;&gt; query = select(Post)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; async_query.select(\n...     Post.rating,\n...     text('users_1.name'),\n...     func.count(Post.title)\n... )\n&gt;&gt;&gt; async_query.group_by('rating', 'user___name')\n&gt;&gt;&gt; rows = async_query.all(scalars=False)\n&gt;&gt;&gt; rows\n[(4, 'John Doe', 1), (5, 'Jane Doe', 1), ...]\n</code></pre></p>"},{"location":"api/async-query/#offset","title":"offset","text":"<pre><code>def offset(offset: int) -&gt; Self\n</code></pre> <p>Apply one OFFSET criteria to the query.</p> <p>Parameters</p> <ul> <li><code>offset</code>: Number of rows to skip.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>NegativeIntegerError</code>: If <code>offset</code> is negative.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await async_query.offset(10).all()\n&gt;&gt;&gt; users\n[User(id=11), User(id=12), ...]\n&gt;&gt;&gt; async_query.offset(-1)\nTraceback (most recent call last):\n    ...\nNegativeIntegerError: offset must be &gt;= 0, got -1\n</code></pre></p>"},{"location":"api/async-query/#skip","title":"skip","text":"<pre><code>def skip(skip: int) -&gt; Self\n</code></pre> <p>Synonym for <code>offset()</code>.</p>"},{"location":"api/async-query/#limit","title":"limit","text":"<pre><code>def limit(limit: int) -&gt; Self\n</code></pre> <p>Apply one LIMIT criteria to the query.</p> <p>Parameters</p> <ul> <li><code>limit</code>: Maximum number of rows to return.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>NegativeIntegerError</code>: If <code>limit</code> is negative.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2), ...]\n&gt;&gt;&gt; users = await async_query.limit(2).all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2)]\n&gt;&gt;&gt; async_query.limit(-1)\nTraceback (most recent call last):\n    ...\nNegativeIntegerError: limit must be &gt;= 0, got -1\n</code></pre>"},{"location":"api/async-query/#take","title":"take","text":"<pre><code>def take(take: int) -&gt; Self\n</code></pre> <p>Synonym for <code>limit()</code>.</p>"},{"location":"api/async-query/#top","title":"top","text":"<pre><code>def top(top: int) -&gt; Self\n</code></pre> <p>Synonym for <code>limit()</code>.</p>"},{"location":"api/async-query/#join","title":"join","text":"<pre><code>def join(\n    *paths: EagerLoadPath, model: type[T] | None = None\n) -&gt; Self\n</code></pre> <p>Apply joined eager loading using LEFT OUTER JOIN.</p> <p>When a tuple is passed, the second element must be boolean, and if <code>True</code>, the join is <code>INNER JOIN</code>, otherwise <code>LEFT OUTER JOIN</code>.</p> Note <p>Only direct relationships can be loaded.</p> <p>Parameters</p> <ul> <li><code>paths</code>: Relationship attributes to join.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>ValueError</code>: If the second element of tuple is not boolean.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(Comment)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; comment = await async_query.join(\n...     Comment.user,         # LEFT OUTER JOIN\n...     (Comment.post, True)  # True = INNER JOIN\n... ).first()\n&gt;&gt;&gt; comment\nComment(id=1)\n&gt;&gt;&gt; comment.user\nUser(id=1)\n&gt;&gt;&gt; comment.post\nPost(id=1)\n&gt;&gt;&gt; async_query.join(\n...     Comment.user,\n...     (Comment.post, 'inner')  # invalid argument\n... )\nTraceback (most recent call last):\n    ...\nValueError: expected boolean for second element of tuple, got str: 'inner'\n</code></pre></p>"},{"location":"api/async-query/#with_subquery","title":"with_subquery","text":"<pre><code>def with_subquery(\n    *paths: EagerLoadPath, model: type[T] | None = None\n) -&gt; Self\n</code></pre> <p>Subqueryload or Selectinload eager loading.</p> <p>Emits a second SELECT statement (Subqueryload) for each relationship to be loaded, across all result objects at once.</p> <p>When a tuple is passed, the second element must be boolean. If it is <code>True</code>, the eager loading strategy is SELECT IN (Selectinload), otherwise SELECT JOIN (Subqueryload).</p> Warning <p>A query which makes use of <code>subqueryload()</code> in conjunction with a limiting modifier such as <code>Query.limit()</code> or <code>Query.offset()</code> should always include <code>Query.order_by()</code> against unique column(s) such as the primary key, so that the additional queries emitted by <code>subqueryload()</code> include the same ordering as used by the parent query. Without it, there is a chance that the inner query could return the wrong rows, as specified in The importance of ordering.</p> <p>Incorrect, LIMIT without ORDER BY: <pre><code>User.options(subqueryload(User.posts)).first()\n</code></pre></p> <p>Incorrect if User.name is not unique: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name).first()\n</code></pre></p> <p>Correct: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name, User.id).first()\n</code></pre></p> <p>To get more information about SELECT IN and SELECT JOIN strategies, , see the <code>loading relationships docs</code>.</p> Note <p>Only direct relationships can be loaded.</p> <p>Parameters</p> <ul> <li><code>paths</code>: Relationship attributes to load.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <p>Raises</p> <ul> <li><code>ValueError</code>: If the second element of tuple is not boolean.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; async_query = AsyncQuery(query)\n&gt;&gt;&gt; users = await async_query.with_subquery(\n...     User.posts,            # SELECT JOIN\n...     (User.comments, True)  # True = SELECT IN\n... ).all()\n&gt;&gt;&gt; users[0]\nUser(id=1)\n&gt;&gt;&gt; users[0].posts              # loaded using SELECT JOIN\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; users[0].posts[0].comments  # loaded using SELECT IN\n[Comment(id=1), Comment(id=2), ...]\n&gt;&gt;&gt; async_query.with_subquery(\n...     User.posts,\n...     (User.comments, 'selectin')  # invalid argument\n... )\nTraceback (most recent call last):\n    ...\nValueError: expected boolean for second element of tuple, got str: 'selectin'\n</code></pre></p> <p>Using a limiting modifier: <pre><code>&gt;&gt;&gt; user = await async_query.with_subquery(\n...     User.posts,            # SELECT JOIN\n...     (User.comments, True)  # True = SELECT IN\n... ).sort('id')  # sorting modifier (Important!!!)\n...  .first()     # limiting modifier\n&gt;&gt;&gt; user = await async_query.with_subquery(\n...     User.posts,            # SELECT JOIN\n...     (User.comments, True)  # True = SELECT IN\n... ).limit(1)    # limiting modifier\n...  .sort('id')  # sorting modifier (Important!!!)\n...  .all()[0]\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user.posts              # loaded using SELECT JOIN\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; user.posts[0].comments  # loaded using SELECT IN\n[Comment(id=1), Comment(id=2), ...]\n</code></pre></p>"},{"location":"api/async-query/#with_schema","title":"with_schema","text":"<pre><code>def with_schema(schema: EagerSchema) -&gt; Self\n</code></pre> <p>Apply joined, subqueryload and selectinload eager loading.</p> <p>Useful for complex cases where you need to load nested relationships in separate queries.</p> Warning <p>A query which makes use of <code>subqueryload()</code> in conjunction with a limiting modifier such as <code>Query.limit()</code> or <code>Query.offset()</code> should always include <code>Query.order_by()</code> against unique column(s) such as the primary key, so that the additional queries emitted by <code>subqueryload()</code> include the same ordering as used by the parent query. Without it, there is a chance that the inner query could return the wrong rows, as specified in The importance of ordering.</p> <p>Incorrect, LIMIT without ORDER BY: <pre><code>User.options(subqueryload(User.posts)).first()\n</code></pre></p> <p>Incorrect if User.name is not unique: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name).first()\n</code></pre></p> <p>Correct: <pre><code>User.options(subqueryload(User.posts)).order_by(User.name, User.id).first()\n</code></pre></p> <p>To get more information about SELECT IN and SELECT JOIN strategies, , see the <code>loading relationships docs</code>.</p> <p>Parameters</p> <ul> <li><code>schema</code>: Dictionary defining the loading strategy.</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: The instance itself for method chaining.</li> </ul> <pre><code>&gt;&gt;&gt; from sqlactive import JOINED, SUBQUERY\n&gt;&gt;&gt; schema = {\n...     User.posts: JOINED,          # joinedload user\n...     User.comments: (SUBQUERY, {  # load comments in separate query\n...         Comment.user: JOINED     # but, in this separate query, join user\n...     })\n... }\n&gt;&gt;&gt; query = select(User)\n&gt;&gt;&gt; aq = AsyncQuery(query)\n&gt;&gt;&gt; user = await aq.with_schema(schema)\n...                .order_by(User.id)  # important when limiting\n...                .first()            # limiting modifier\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; user.posts\n[Post(id=1), Post(id=2), ...]\n&gt;&gt;&gt; user.posts[0].comments\n[Comment(id=1), Comment(id=2), ...]\n&gt;&gt;&gt; user.posts[0].comments[0].user\nUser(id=1)\n</code></pre>"},{"location":"api/db-connection-helper/","title":"DB Connection Helper","text":"<p>The <code>DBConnection</code> class provides functions for connecting to a database and initializing tables.</p>"},{"location":"api/db-connection-helper/#usage","title":"Usage","text":"<pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\n\ndb = DBConnection(DATABASE_URL, echo=False)\n</code></pre> <p>This is a shortcut:</p> <pre><code>from asyncio import current_task\nfrom sqlalchemy.ext.asyncio import (\n    create_async_engine, async_sessionmaker, async_scoped_session\n)\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nasync_engine = create_async_engine(DATABASE_URL, echo=False)\nasync_sessionmaker = async_sessionmaker(bind=async_engine, expire_on_commit=False)\nasync_scoped_session = async_scoped_session(async_sessionmaker, scopefunc=current_task)\n</code></pre> <p>Note that the keyword arguments of the <code>DBConnection</code> class are passed to the <code>sqlalchemy.ext.asyncio.create_async_engine</code> function.</p>"},{"location":"api/db-connection-helper/#api-reference","title":"API Reference","text":""},{"location":"api/db-connection-helper/#methods","title":"Methods","text":"<p>The <code>DBConnection</code> class has the following methods:</p> <ul> <li><code>init_db()</code>: Initialize the database tables.</li> <li><code>close()</code>: Close the database connection.</li> </ul>"},{"location":"api/db-connection-helper/#init_db","title":"init_db","text":"<p>Initialize the database tables. It also sets the session of the base model to the <code>async_scoped_session</code> async session factory:</p> <pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db()) # Initialize the database\n</code></pre> <p>If your base model is not <code>ActiveRecordBaseModel</code> you must pass your base model class to this method in the <code>base_model</code> argument:</p> <pre><code>from sqlactive import DBConnection, ActiveRecordBaseModel\n\n# Note that it does not matter if your base model\n# inherits from `ActiveRecordBaseModel`, you still\n# need to pass it to this method\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db(BaseModel)) # Pass your base model\n</code></pre>"},{"location":"api/db-connection-helper/#close","title":"close","text":"<p>Close the database connection. It also sets the session of the base model to <code>None</code>:</p> <pre><code>from sqlactive import DBConnection\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db())\n\n# Perform operations...\n\nasyncio.run(conn.close()) # Close the database connection\n</code></pre> <p>If your base model is not <code>ActiveRecordBaseModel</code> you should pass your base model cl0ass to this method in the <code>base_model</code> argument:</p> <pre><code>from sqlactive import DBConnection, ActiveRecordBaseModel\n\n# Note that it does not matter if your base model\n# inherits from `ActiveRecordBaseModel`, you still\n# need to pass it to this method\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\nDATABASE_URL = 'sqlite+aiosqlite://'\nconn = DBConnection(DATABASE_URL, echo=True)\nasyncio.run(conn.init_db())\n\n# Perform operations...\n\nasyncio.run(conn.close(BaseModel)) # Pass your base model\n</code></pre>"},{"location":"api/inspection-mixin/","title":"Inspection Mixin","text":"<p>The <code>InspectionMixin</code> class provides attributes and properties inspection functionality for SQLAlchemy models.</p> Note <p>This mixin is intended to extend the functionality of the <code>Smart Queries</code> and <code>Serialization</code> mixins. It is not intended to be used on its own.</p> Info <p>The examples below assume the following models:</p> <pre><code>from sqlalchemy import ForeignKey, String\nfrom sqlalchemy.ext.hybrid import hybrid_method, hybrid_property\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom sqlactive.base_model import ActiveRecordBaseModel\n\n\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    username: Mapped[str] = mapped_column(\n        String(18), nullable=False, unique=True\n    )\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\n    @hybrid_property\n    def is_adult(self) -&gt; int:\n        return self.age &gt; 18\n\n    @hybrid_method\n    def older_than(self, other: 'User') -&gt; bool:\n        return self.age &gt; other.age\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n\n\nclass Product(BaseModel):\n    __tablename__ = 'products'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    description: Mapped[str] = mapped_column(String(100), nullable=False)\n    price: Mapped[float] = mapped_column(nullable=False)\n\n    sells: Mapped[list['Sell']] = relationship(\n        back_populates='product', viewonly=True\n    )\n\n\nclass Sell(BaseModel):\n    __tablename__ = 'sells'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    product_id: Mapped[int] = mapped_column(\n        ForeignKey('products.id'), primary_key=True\n    )\n    quantity: Mapped[int] = mapped_column(nullable=False)\n\n    product: Mapped['Product'] = relationship(back_populates='sells')\n</code></pre>"},{"location":"api/inspection-mixin/#api-reference","title":"API Reference","text":""},{"location":"api/inspection-mixin/#properties","title":"Properties","text":""},{"location":"api/inspection-mixin/#id_str","title":"id_str","text":"<pre><code>@property\ndef id_str() -&gt; str\n</code></pre> <p>Return a string representation of the primary key.</p> <p>If the primary key is composite, returns a comma-separated list of key-value pairs.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; bob = User.insert(name='Bob')\n&gt;&gt;&gt; bob.id_str\nid=1\n&gt;&gt;&gt; sell = Sell(id=1, product_id=1)\n&gt;&gt;&gt; sell.id_str\nid=1, product_id=1\n</code></pre>"},{"location":"api/inspection-mixin/#class-properties","title":"Class Properties","text":""},{"location":"api/inspection-mixin/#columns","title":"columns","text":"<pre><code>@classproperty\ndef columns() -&gt; list[str]\n</code></pre> <p>Return a list of column names.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.columns\n['id', 'username', 'name', 'age', 'created_at', 'updated_at']\n</code></pre>"},{"location":"api/inspection-mixin/#string_columns","title":"string_columns","text":"<pre><code>@classproperty\ndef string_columns() -&gt; list[str]\n</code></pre> <p>Return a list of string column names.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.string_columns\n['username', 'name']\n</code></pre>"},{"location":"api/inspection-mixin/#primary_keys_full","title":"primary_keys_full","text":"<pre><code>@classproperty\ndef primary_keys_full() -&gt; tuple[Column[Any], ...]\n</code></pre> <p>Return the columns that form the primary key.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.primary_keys_full\n(Column('id', Integer(), table=&lt;users&gt;, primary_key=True, nullable=False),)\n</code></pre>"},{"location":"api/inspection-mixin/#primary_keys","title":"primary_keys","text":"<pre><code>@classproperty\ndef primary_keys() -&gt; list[str]\n</code></pre> <p>Return the names of the primary key columns.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.primary_keys\n['id']\n</code></pre>"},{"location":"api/inspection-mixin/#primary_key_name","title":"primary_key_name","text":"<pre><code>@classproperty\ndef primary_key_name() -&gt; str\n</code></pre> <p>Return the primary key name of the model.</p> Warning <p>This property can only be used if the model has a single primary key. If the model has a composite primary key, an <code>CompositePrimaryKeyError</code> is raised.</p> <p>Raises</p> <ul> <li><code>CompositePrimaryKeyError</code>: If the model has a composite primary key.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.primary_key_name\nid\n&gt;&gt;&gt; Sell.primary_key_name\nTraceback (most recent call last):\n...\nCompositePrimaryKeyError: model 'Sell' has a composite primary key\n</code></pre>"},{"location":"api/inspection-mixin/#relations","title":"relations","text":"<pre><code>@classproperty\ndef relations() -&gt; list[str]\n</code></pre> <p>Return a list of relationship names.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.relations\n['posts', 'comments']\n</code></pre>"},{"location":"api/inspection-mixin/#settable_relations","title":"settable_relations","text":"<pre><code>@classproperty\ndef settable_relations() -&gt; list[str]\n</code></pre> <p>Return a list of settable (not viewonly) relationship names.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.settable_relations\n['posts', 'comments']\n&gt;&gt;&gt; Product.settable_relations\n[]\n</code></pre>"},{"location":"api/inspection-mixin/#hybrid_properties","title":"hybrid_properties","text":"<pre><code>@classproperty\ndef hybrid_properties() -&gt; list[str]\n</code></pre> <p>Return a list of hybrid property names.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.hybrid_properties\n['is_adult']\n</code></pre>"},{"location":"api/inspection-mixin/#hybrid_methods_full","title":"hybrid_methods_full","text":"<pre><code>@classproperty\ndef hybrid_methods_full() -&gt; dict[str, hybrid_method[..., Any]]\n</code></pre> <p>Return a dict of hybrid methods.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.hybrid_methods_full\n{'older_than': hybrid_method(...)}\n</code></pre>"},{"location":"api/inspection-mixin/#hybrid_methods","title":"hybrid_methods","text":"<pre><code>@classproperty\ndef hybrid_methods() -&gt; list[str]\n</code></pre> <p>Return a list of hybrid method names.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.hybrid_methods\n['older_than']\n</code></pre>"},{"location":"api/inspection-mixin/#filterable_attributes","title":"filterable_attributes","text":"<pre><code>@classproperty\ndef filterable_attributes() -&gt; list[str]\n</code></pre> <p>Return a list of filterable attributes.</p> <p>These are all columns, relations, hybrid properties and hybrid methods.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.filterable_attributes\n&gt;&gt;&gt; ['id', 'username', 'name', 'age', 'created_at', 'updated_at', 'posts', 'comments', 'is_adult', 'older_than']\n</code></pre>"},{"location":"api/inspection-mixin/#sortable_attributes","title":"sortable_attributes","text":"<pre><code>@classproperty\ndef sortable_attributes() -&gt; list[str]\n</code></pre> <p>Return a list of sortable attributes.</p> <p>These are all columns and hybrid properties.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.sortable_attributes\n['id', 'username', 'name', 'age', 'created_at', 'updated_at', 'is_adult']\n</code></pre>"},{"location":"api/inspection-mixin/#settable_attributes","title":"settable_attributes","text":"<pre><code>@classproperty\ndef settable_attributes() -&gt; list[str]\n</code></pre> <p>Return a list of settable attributes.</p> <p>These are all columns, settable relations and hybrid properties.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.settable_attributes\n['username', 'name', 'age', 'created_at', 'updated_at', 'posts', 'comments', 'is_adult']\n</code></pre>"},{"location":"api/inspection-mixin/#searchable_attributes","title":"searchable_attributes","text":"<pre><code>@classproperty\ndef searchable_attributes() -&gt; list[str]\n</code></pre> <p>Return a list of searchable attributes.</p> <p>These are all string columns.</p> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.searchable_attributes\n['username', 'name']\n</code></pre>"},{"location":"api/inspection-mixin/#instance-methods","title":"Instance Methods","text":""},{"location":"api/inspection-mixin/#repr","title":"repr","text":"<pre><code>def __repr__() -&gt; str\n</code></pre> <p>Return a string representation of the model.</p> <p>Representation format is <code>ClassName(pk1=value1, pk2=value2, ...)</code></p> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.get(id=1)\n&gt;&gt;&gt; user\nUser(id=1)\n&gt;&gt;&gt; users = await User.find(name__endswith='Doe').all()\n&gt;&gt;&gt; users\n[User(id=1), User(id=2)]\n</code></pre>"},{"location":"api/inspection-mixin/#class-methods","title":"Class Methods","text":""},{"location":"api/inspection-mixin/#get_class_of_relation","title":"get_class_of_relation","text":"<pre><code>@classmethod\ndef get_class_of_relation(relation_name: str) -&gt; type[Self]\n</code></pre> <p>Get the class of a relationship by its name.</p> <p>Parameters</p> <ul> <li><code>relation_name</code>: The name of the relationship.</li> </ul> <p>Returns</p> <ul> <li><code>type[Self]</code>: The class of the relationship.</li> </ul> <p>Raises</p> <ul> <li><code>RelationError</code>: If the relation is not found.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; User.get_class_of_relation('posts')\n&lt;class 'Post'&gt;\n&gt;&gt;&gt; User.get_class_of_relation('comments')\n&lt;class 'Comment'&gt;\n&gt;&gt;&gt; User.get_class_of_relation('sells')\nTraceback (most recent call last):\n    ...\nRelationError: no such relation: 'sells' in model 'User'\n</code></pre>"},{"location":"api/native-sqlalchemy-queries/","title":"Native SQLAlchemy queries","text":"<p>You can asynchronously execute native SQLAlchemy queries using the <code>sqlactive.conn.execute</code> function. It uses the <code>AsyncSession</code> of the <code>ActiveRecordBaseModel</code> class and return a buffered <code>sqlalchemy.engine.Result</code> object.</p>"},{"location":"api/native-sqlalchemy-queries/#usage","title":"Usage","text":"<pre><code>from sqlalchemy import select, func\nfrom sqlactive import execute\n\nquery = select(User.age, func.count(User.id)).group_by(User.age)\nresult = await execute(query)\n</code></pre> <p>The <code>statement</code>, <code>params</code> and <code>kwargs</code> arguments of this function are the same as the arguments of the <code>execute</code> method of the <code>sqlalchemy.ext.asyncio.AsyncSession</code> class.</p> <p>If your base model is not <code>ActiveRecordBaseModel</code> you must pass your base model class to the <code>base_model</code> argument of the <code>execute</code> method:</p> <pre><code>from sqlalchemy import select, func\nfrom sqlactive import ActiveRecordBaseModel, execute\n\n# Note that it does not matter if your base model\n# inherits from `ActiveRecordBaseModel`, you still\n# need to pass it to this method\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n    # ...\n\nquery = select(User.age, func.count(User.id)).group_by(User.age)\nresult = await execute(query, BaseModel)  # or execute(query, User)\n</code></pre> Warning <p>Your base model must have a session in order to use this method. Otherwise, it will raise an <code>NoSessionError</code> exception. If you are not using the <code>DBConnection</code> class to initialize your base model, you can call its <code>set_session</code> method to set the session.</p>"},{"location":"api/serialization-mixin/","title":"Serialization Mixin","text":"<p>The <code>SerializationMixin</code> class provides methods for serializing and deserializing SQLAlchemy models.</p> <p>It uses the functionality of the <code>Inspection Mixin</code>.</p> Info <p>The examples below assume the following models:</p> <pre><code>from sqlalchemy import ForeignKey, String\nfrom sqlalchemy.ext.hybrid import hybrid_method, hybrid_property\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom sqlactive.base_model import ActiveRecordBaseModel\n\n\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    username: Mapped[str] = mapped_column(\n        String(18), nullable=False, unique=True\n    )\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\n    @hybrid_property\n    def is_adult(self) -&gt; int:\n        return self.age &gt; 18\n\n    @hybrid_method\n    def older_than(self, other: 'User') -&gt; bool:\n        return self.age &gt; other.age\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n\n\nclass Product(BaseModel):\n    __tablename__ = 'products'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    description: Mapped[str] = mapped_column(String(100), nullable=False)\n    price: Mapped[float] = mapped_column(nullable=False)\n\n    sells: Mapped[list['Sell']] = relationship(\n        back_populates='product', viewonly=True\n    )\n\n\nclass Sell(BaseModel):\n    __tablename__ = 'sells'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    product_id: Mapped[int] = mapped_column(\n        ForeignKey('products.id'), primary_key=True\n    )\n    quantity: Mapped[int] = mapped_column(nullable=False)\n\n    product: Mapped['Product'] = relationship(back_populates='sells')\n</code></pre>"},{"location":"api/serialization-mixin/#api-reference","title":"API Reference","text":""},{"location":"api/serialization-mixin/#serialization","title":"Serialization","text":""},{"location":"api/serialization-mixin/#to_dict","title":"to_dict","text":"<pre><code>@classmethod\ndef to_dict(\n    nested: bool = False,\n    hybrid_attributes: bool = False,\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None,\n) -&gt; dict[str, Any]\n</code></pre> <p>Serialize the model to a dictionary.</p> <p>Parameters</p> <ul> <li><code>nested</code>: Set to <code>True</code> to include nested relationships (default: <code>False</code>).</li> <li><code>hybrid_attributes</code>: Set to <code>True</code> to include hybrid attributes (default: <code>False</code>).</li> <li><code>exclude</code>: Exclude specific attributes from the result (default: <code>None</code>).</li> <li><code>nested_exclude</code>: Exclude specific attributes from nested relationships (default: <code>None</code>).</li> </ul> <p>Returns</p> <ul> <li><code>dict[str, Any]</code>: Serialized model.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.get(id=1)\n&gt;&gt;&gt; user.to_dict()\n{'id': 1, 'username': 'user1', 'name': 'John', 'age': 30, ...}\n&gt;&gt;&gt; user.to_dict(nested=True)\n{'id': 1, 'username': 'user1', 'name': 'John', 'age': 30, 'posts': [...], ...}\n&gt;&gt;&gt; user.to_dict(hybrid_attributes=True)\n{'id': 1, 'username': 'user1', 'name': 'John', 'age': 30, 'posts_count': 3, ...}\n&gt;&gt;&gt; user.to_dict(exclude=['id', 'username'])\n{'name': 'John', 'age': 30, ...}\n</code></pre>"},{"location":"api/serialization-mixin/#to_json","title":"to_json","text":"<pre><code>@classmethod\ndef to_json(\n    nested: bool = False,\n    hybrid_attributes: bool = False,\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None,\n    ensure_ascii: bool = False,\n    indent: int | str | None = None,\n    sort_keys: bool = False\n) -&gt; str\n</code></pre> <p>Serialize the model to JSON.</p> <p>Calls the <code>to_dict()</code> method and dumps it to JSON.</p> <p>Parameters</p> <ul> <li><code>nested</code>: Set to <code>True</code> to include nested relationships (default: <code>False</code>).</li> <li><code>hybrid_attributes</code>: Set to <code>True</code> to include hybrid attributes (default: <code>False</code>).</li> <li><code>exclude</code>: Exclude specific attributes from the result (default: <code>None</code>).</li> <li><code>nested_exclude</code>: Exclude specific attributes from nested relationships (default: <code>None</code>).</li> <li><code>ensure_ascii</code>: If False, then the return value can contain non-ASCII characters if they appear in strings contained in obj. Otherwise, all such characters are escaped in JSON strings (default: <code>False</code>).</li> <li><code>indent</code>: If indent is a non-negative integer, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines. <code>None</code> is the most compact representation (default: <code>None</code>).</li> <li><code>sort_keys</code>: Sort dictionary keys (default: <code>False</code>).</li> </ul> <p>Returns</p> <ul> <li><code>str</code>: Serialized model.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.get(id=1)\n&gt;&gt;&gt; user.to_json()\n{\"id\": 1, \"username\": \"user1\", \"name\": \"John\", \"age\": 30, ...}\n&gt;&gt;&gt; user.to_json(nested=True)\n{\"id\": 1, \"username\": \"user1\", \"name\": \"John\", \"age\": 30, \"posts\": [...], ...}\n&gt;&gt;&gt; user.to_json(hybrid_attributes=True)\n{\"id\": 1, \"username\": \"user1\", \"name\": \"John\", \"age\": 30, \"posts_count\": 3, ...}\n&gt;&gt;&gt; user.to_json(exclude=['id', 'username'])\n{\"name\": \"John\", \"age\": 30, ...}\n</code></pre>"},{"location":"api/serialization-mixin/#deserialization","title":"Deserialization","text":""},{"location":"api/serialization-mixin/#from_dict","title":"from_dict","text":"<pre><code>@classmethod\ndef from_dict(\n    data: dict[str, Any] | list[dict[str, Any]],\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None\n) -&gt; Self | list[Self]\n</code></pre> <p>Deserialize a dictionary to the model.</p> <p>Sets the attributes of the model with the values of the dictionary.</p> <p>Parameters</p> <ul> <li><code>data</code>: Data to deserialize.</li> <li><code>exclude</code>: Exclude specific keys from the dictionary (default: <code>None</code>).</li> <li><code>nested_exclude</code>: Exclude specific attributes from nested relationships (default: <code>None</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Self</code>: Deserialized model.</li> <li><code>list[Self]</code>: Deserialized models.</li> </ul> <p>Raises</p> <ul> <li><code>ModelAttributeError</code>: If attribute does not exist.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.from_dict({'name': 'John', 'age': 30})\n&gt;&gt;&gt; user.to_dict()\n{'name': 'John', 'age': 30, ...}\n&gt;&gt;&gt; users = await User.from_dict(\n...     [{'name': 'John', 'age': 30}, {'name': 'Jane', 'age': 25}]\n... )\n&gt;&gt;&gt; users[0].to_dict()\n{'name': 'John', 'age': 30, ...}\n&gt;&gt;&gt; users[1].to_dict()\n{'name': 'Jane', 'age': 25, ...}\n</code></pre>"},{"location":"api/serialization-mixin/#from_json","title":"from_json","text":"<pre><code>@classmethod\ndef from_json(\n    json_string: str,\n    exclude: list[str] | None = None,\n    nested_exclude: list[str] | None = None\n) -&gt; Any\n</code></pre> <p>Deserialize a JSON string to the model.</p> <p>Loads the JSON string and sets the attributes of the model with the values of the JSON object using the <code>from_dict</code> method.</p> <p>Parameters</p> <ul> <li><code>json_string</code>: JSON string.</li> <li><code>exclude</code>: Exclude specific keys from the dictionary (default: <code>None</code>).</li> <li><code>nested_exclude</code>: Exclude specific attributes from nested relationships (default: <code>None</code>).</li> </ul> <p>Returns</p> <ul> <li><code>Any</code>: Deserialized model or models.</li> </ul> <p>Raises</p> <ul> <li><code>ModelAttributeError</code>: If attribute does not exist.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; user = await User.from_json('{\"name\": \"John\", \"age\": 30}')\n&gt;&gt;&gt; user.to_dict()\n{'name': 'John', 'age': 30, ...}\n&gt;&gt;&gt; users = await User.from_json(\n...     '[{\"name\": \"John\", \"age\": 30}, {\"name\": \"Jane\", \"age\": 25}]'\n... )\n&gt;&gt;&gt; users[0].to_dict()\n{'name': 'John', 'age': 30, ...}\n&gt;&gt;&gt; users[1].to_dict()\n{'name': 'Jane', 'age': 25, ...}\n</code></pre>"},{"location":"api/session-mixin/","title":"Session Mixin","text":"<p>the <code>SessionMixin</code> class provides functions for handling asynchronous scoped sessions.</p>"},{"location":"api/session-mixin/#api-reference","title":"API Reference","text":""},{"location":"api/session-mixin/#class-properties","title":"Class Properties","text":""},{"location":"api/session-mixin/#asyncsession","title":"AsyncSession","text":"<pre><code>@classproperty\ndef AsyncSession() -&gt; async_scoped_session[AsyncSession]\n</code></pre> <p>Async session factory.</p> <p>Raises</p> <ul> <li><code>NoSessionError</code>: If no session is available.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>async with SaActiveRecord.AsyncSession() as session:\n    session.add(model)\n    await session.commit()\n</code></pre></p>"},{"location":"api/session-mixin/#class-methods","title":"Class Methods","text":""},{"location":"api/session-mixin/#set_session","title":"set_session","text":"<pre><code>@classmethod\ndef set_session(session: async_scoped_session[AsyncSession])\n</code></pre> <p>Set the async session factory.</p> <p>Parameters</p> <ul> <li><code>session</code>: Async session factory.</li> </ul> <p>Examples</p> <pre><code>from asyncio import current_task\nfrom sqlalchemy.ext.asyncio import (\n    ...,\n    async_scoped_session,\n)\n\nfrom sqlactive import ActiveRecordBaseModel\n\nclass MyModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n...  # other code\nasync_scoped_session = async_scoped_session(\n  async_sessionmaker,\n  scopefunc=current_task\n)\n\n# Set the session\nActiveRecordBaseModel.set_session(async_scoped_session(AsyncSession))\n</code></pre>"},{"location":"api/session-mixin/#close_session","title":"close_session","text":"<pre><code>@classmethod\ndef close_session()\n</code></pre> <p>Close the async session.</p>"},{"location":"api/smart-query-mixin/","title":"Smart Query Mixin","text":"<p>The <code>SmartQueryMixin</code> class provides advanced query functionality for SQLAlchemy models, allowing you to filter, sort, group and eager load data in a single query, making it easier to retrieve specific data from the database.</p> <p>It uses the functionality of the <code>Inspection Mixin</code>.</p> Info <p>This mixin is intended to extend the functionality of the <code>Active Record Mixin</code> which the examples below are based on. It also extends the functionality of the <code>Async Query</code> wrapper. It is not intended to be used on its own.</p> Warning <p>All relations used in filtering/sorting/grouping should be explicitly set, not just being a <code>backref</code>. See the About Relationships section for more information.</p> Info <p>The examples below assume the following models:</p> <pre><code>from sqlalchemy import ForeignKey, String\nfrom sqlalchemy.ext.hybrid import hybrid_method, hybrid_property\nfrom sqlalchemy.orm import Mapped, mapped_column, relationship\n\nfrom sqlactive.base_model import ActiveRecordBaseModel\n\n\nclass BaseModel(ActiveRecordBaseModel):\n    __abstract__ = True\n\n\nclass User(BaseModel):\n    __tablename__ = 'users'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    username: Mapped[str] = mapped_column(\n        String(18), nullable=False, unique=True\n    )\n    name: Mapped[str] = mapped_column(String(50), nullable=False)\n    age: Mapped[int] = mapped_column(nullable=False)\n\n    posts: Mapped[list['Post']] = relationship(back_populates='user')\n    comments: Mapped[list['Comment']] = relationship(back_populates='user')\n\n    @hybrid_property\n    def is_adult(self) -&gt; int:\n        return self.age &gt; 18\n\n    @hybrid_method\n    def older_than(self, other: 'User') -&gt; bool:\n        return self.age &gt; other.age\n\n\nclass Post(BaseModel):\n    __tablename__ = 'posts'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    title: Mapped[str] = mapped_column(String(100), nullable=False)\n    body: Mapped[str] = mapped_column(nullable=False)\n    rating: Mapped[int] = mapped_column(nullable=False)\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    user: Mapped['User'] = relationship(back_populates='posts')\n    comments: Mapped[list['Comment']] = relationship(back_populates='post')\n\n\nclass Comment(BaseModel):\n    __tablename__ = 'comments'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    body: Mapped[str] = mapped_column(nullable=False)\n    post_id: Mapped[int] = mapped_column(ForeignKey('posts.id'))\n    user_id: Mapped[int] = mapped_column(ForeignKey('users.id'))\n\n    post: Mapped['Post'] = relationship(back_populates='comments')\n    user: Mapped['User'] = relationship(back_populates='comments')\n\n\nclass Product(BaseModel):\n    __tablename__ = 'products'\n\n    id: Mapped[int] = mapped_column(\n        primary_key=True, autoincrement=True, index=True\n    )\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    description: Mapped[str] = mapped_column(String(100), nullable=False)\n    price: Mapped[float] = mapped_column(nullable=False)\n\n    sells: Mapped[list['Sell']] = relationship(\n        back_populates='product', viewonly=True\n    )\n\n\nclass Sell(BaseModel):\n    __tablename__ = 'sells'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    product_id: Mapped[int] = mapped_column(\n        ForeignKey('products.id'), primary_key=True\n    )\n    quantity: Mapped[int] = mapped_column(nullable=False)\n\n    product: Mapped['Product'] = relationship(back_populates='sells')\n</code></pre>"},{"location":"api/smart-query-mixin/#core-features","title":"Core Features","text":""},{"location":"api/smart-query-mixin/#smart-queries","title":"Smart Queries","text":"<p>Smart queries allow you to filter, sort, group and eager load data in a single query.</p> <pre><code>users = await User.smart_query(\n    criteria=(User.age &gt;= 18,),\n    filters={'name__like': '%Bob%'},\n    sort_columns=(User.username,),\n    sort_attrs=['-created_at'],\n    group_columns=(User.username,),\n    group_attrs=['age'],\n    schema={User.posts: 'joined'}\n).all()\n</code></pre>"},{"location":"api/smart-query-mixin/#filtering","title":"Filtering","text":"<p>You can filter data using native SQLAlchemy filter expressions.</p> <pre><code>users = await User.smart_query(\n    criteria=(User.age &gt;= 18,)\n).all()\n</code></pre> <p>Also, you can filter data using Django-like filter expressions.</p> <pre><code>users = await User.smart_query(\n    filters={'name__like': '%Bob%'}\n).all()\n</code></pre>"},{"location":"api/smart-query-mixin/#sorting","title":"Sorting","text":"<p>You can sort data using native SQLAlchemy sort expressions with the <code>sort_columns</code> parameter.</p> <pre><code>users = await User.smart_query(\n    sort_columns=(User.username,)\n).all()\n</code></pre> <p>Also, you can sort data using Django-like sort expressions with the <code>sort_attrs</code> parameter.</p> <pre><code>users = await User.smart_query(\n    sort_attrs=['-created_at']\n).all()\n</code></pre>"},{"location":"api/smart-query-mixin/#grouping","title":"Grouping","text":"<p>You can group data using native SQLAlchemy group expressions with the <code>group_columns</code> parameter.</p> <pre><code>users = await User.smart_query(\n    group_columns=(User.username,)\n).all()\n</code></pre> <p>Also, you can group data using Django-like group expressions with the <code>group_attrs</code> parameter.</p> <pre><code>users = await User.smart_query(\n    group_attrs=['age']\n).all()\n</code></pre>"},{"location":"api/smart-query-mixin/#eager-loading","title":"Eager Loading","text":"<p>You can eager load relationships using various loading strategies with the <code>schema</code> parameter.</p> <pre><code>users = await User.smart_query(\n    schema={User.posts: 'joined'}\n).all()\n</code></pre>"},{"location":"api/smart-query-mixin/#searching","title":"Searching","text":"<p>You can search data using the <code>search</code> method.</p> <pre><code>users = await User.search(\n    query=User.query,\n    search_term='Bob',\n    columns=(User.name, User.username),\n).all()\n</code></pre>"},{"location":"api/smart-query-mixin/#api-reference","title":"API Reference","text":"<p>The <code>SmartQueryMixin</code> class provides three low-level methods for building filter, sort, group and eager load expressions:</p> <ul> <li><code>filter_expr</code>: Builds filter expressions.</li> <li><code>order_expr</code>: Builds order expressions.</li> <li><code>columns_expr</code>: Builds column expressions.</li> <li><code>eager_expr</code>: Builds eager load expressions.</li> <li><code>smart_query</code>: Builds a smart query (filter, sort, group and eager load).</li> <li><code>apply_search_filter</code>: Applies a search filter to the query.</li> </ul>"},{"location":"api/smart-query-mixin/#filter-operators","title":"Filter Operators","text":"<p>The <code>SmartQueryMixin</code> class provides a set of Django-like filter operators for building filter expressions.</p>"},{"location":"api/smart-query-mixin/#isnull","title":"isnull","text":"<p>Whether the value is null.</p> <pre><code>&gt;&gt;&gt; posts = await Post.where(topic__isnull=True).all()\n&gt;&gt;&gt; post.topic is None for post in posts\nTrue\n&gt;&gt;&gt; posts = await Post.where(topic__isnull=False).all()\n&gt;&gt;&gt; post.topic is not None for post in posts\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#exact","title":"exact","text":"<p>Equal to.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__exact=25).all()\n&gt;&gt;&gt; all([user.age == 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#eq","title":"eq","text":"<p>Same as <code>exact</code>.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__eq=25).all()\n&gt;&gt;&gt; all([user.age == 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#ne","title":"ne","text":"<p>Not equal to.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__ne=25).all()\n&gt;&gt;&gt; all([user.age != 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#gt","title":"gt","text":"<p>Greater than.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__gt=25).all()\n&gt;&gt;&gt; all([user.age &gt; 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#ge","title":"ge","text":"<p>Greater than or equal to.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__ge=25).all()\n&gt;&gt;&gt; all([user.age &gt;= 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#lt","title":"lt","text":"<p>Less than.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__lt=25).all()\n&gt;&gt;&gt; all([user.age &lt; 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#le","title":"le","text":"<p>Less than or equal to.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__le=25).all()\n&gt;&gt;&gt; all([user.age &lt;= 25 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#in","title":"in","text":"<p>Included in.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__in=[20, 30]).all()\n&gt;&gt;&gt; all([user.age == 20 or user.age == 30 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#notin","title":"notin","text":"<p>Not included in.</p> <pre><code>&gt;&gt;&gt; users = await User.where(age__notin=[20, 30]).all()\n&gt;&gt;&gt; all([user.age != 20 and user.age != 30 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#between","title":"between","text":"<p>Inside a range.</p> <pre><code>&gt;&gt;&gt; await User.where(age__between=[20, 30]).all()\n&gt;&gt;&gt; all([user.age &gt;= 20 and user.age &lt;= 30 for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#like","title":"like","text":"<p>SQL <code>LIKE</code> clause.</p> <pre><code>&gt;&gt;&gt; await User.where(username__like='Ji%').all()\n&gt;&gt;&gt; all([user.username.startswith('Ji') for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#ilike","title":"ilike","text":"<p>Case-insensitive SQL <code>LIKE</code> clause for PostgreSQL.</p> <p>When used with other backends, such as MySQL, is the same as <code>like</code>.</p> <pre><code>&gt;&gt;&gt; await User.where(username__ilike='ji%').all()\n&gt;&gt;&gt; all([user.username.startswith('Ji') for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#startswith","title":"startswith","text":"<p>Start with.</p> <pre><code>&gt;&gt;&gt; await User.where(username__startswith='Ji').all()\n&gt;&gt;&gt; all([user.username.startswith('Ji') for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#istartswith","title":"istartswith","text":"<p>Case-insensitive start with.</p> <pre><code>&gt;&gt;&gt; await User.where(username__istartswith='ji').all()\n&gt;&gt;&gt; all([user.username.startswith('Ji') for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#endswith","title":"endswith","text":"<p>End with.</p> <pre><code>&gt;&gt;&gt; await User.where(name__endswith='Anderson').all()\n&gt;&gt;&gt; all([user.name.endswith('Anderson') for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#iendswith","title":"iendswith","text":"<p>Case-insensitive end with.</p> <pre><code>&gt;&gt;&gt; await User.where(name__iendswith='anderson').all()\n&gt;&gt;&gt; all([user.name.endswith('Anderson') for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#contains","title":"contains","text":"<p>Contains a substring (case-insensitive).</p> <pre><code>&gt;&gt;&gt; await User.where(name__contains='Wa').all()\n&gt;&gt;&gt; all(['wa' in user.name.lower() for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#year","title":"year","text":"<p>Date year is equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__year=today.year).all()\n&gt;&gt;&gt; all([user.created_at.year == today.year for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#year_ne","title":"year_ne","text":"<p>Date year is not equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__year_ne=today.year).all()\n&gt;&gt;&gt; all([user.created_at.year != (today.year - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#year_gt","title":"year_gt","text":"<p>Date year is greater than.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__year_gt=today.year).all()\n&gt;&gt;&gt; all([user.created_at.year &gt; (today.year - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#year_ge","title":"year_ge","text":"<p>Date year is greater than or equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__year_ge=today.year).all()\n&gt;&gt;&gt; all([user.created_at.year &gt;= (today.year - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#year_lt","title":"year_lt","text":"<p>Date year is less than.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__year_lt=today.year).all()\n&gt;&gt;&gt; all([user.created_at.year &lt; (today.year + 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#year_le","title":"year_le","text":"<p>Date year is less than or equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__year_le=today.year).all()\n&gt;&gt;&gt; all([user.created_at.year &lt;= (today.year + 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#month","title":"month","text":"<p>Date month is equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__month=today.month).all()\n&gt;&gt;&gt; all([user.created_at.month == today.month for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#month_ne","title":"month_ne","text":"<p>Date month is not equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__month_ne=today.month).all()\n&gt;&gt;&gt; all([user.created_at.month != (today.month - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#month_gt","title":"month_gt","text":"<p>Date month is greater than.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__month_gt=today.month).all()\n&gt;&gt;&gt; all([user.created_at.month &gt; (today.month - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#month_ge","title":"month_ge","text":"<p>Date month is greater than or equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__month_ge=today.month).all()\n&gt;&gt;&gt; all([user.created_at.month &gt;= (today.month - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#month_lt","title":"month_lt","text":"<p>Date month is less than.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__month_lt=today.month).all()\n&gt;&gt;&gt; all([user.created_at.month &lt; (today.month + 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#month_le","title":"month_le","text":"<p>Date month is less than or equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__month_le=today.month).all()\n&gt;&gt;&gt; all([user.created_at.month &lt;= (today.month + 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#day","title":"day","text":"<p>Date day is equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__day=today.day).all()\n&gt;&gt;&gt; all([user.created_at.day == today.day for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#day_ne","title":"day_ne","text":"<p>Date day is not equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__day_ne=today.day).all()\n&gt;&gt;&gt; all([user.created_at.day != (today.day - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#day_gt","title":"day_gt","text":"<p>Date day is greater than.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__day_gt=today.day).all()\n&gt;&gt;&gt; all([user.created_at.day &gt; (today.day - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#day_ge","title":"day_ge","text":"<p>Date day is greater than or equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__day_ge=today.day).all()\n&gt;&gt;&gt; all([user.created_at.day &gt;= (today.day - 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#day_lt","title":"day_lt","text":"<p>Date day is less than.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__day_lt=today.day).all()\n&gt;&gt;&gt; all([user.created_at.day &lt; (today.day + 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#day_le","title":"day_le","text":"<p>Date day is less than or equal to.</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; today = datetime.today()\n&gt;&gt;&gt; await User.where(created_at__day_le=today.day).all()\n&gt;&gt;&gt; all([user.created_at.day &lt;= (today.day + 1) for user in users])\nTrue\n</code></pre>"},{"location":"api/smart-query-mixin/#methods","title":"Methods","text":""},{"location":"api/smart-query-mixin/#filter_expr","title":"filter_expr","text":"<pre><code>@classmethod\ndef filter_expr(**filters: object) -&gt; list[ColumnElement[Any]]\n</code></pre> <p>Transform Django-style filters into SQLAlchemy expressions.</p> <p>Takes keyword arguments like: <pre><code>{'rating': 5, 'user_id__in': [1,2]}\n</code></pre> and returns list of expressions like: <pre><code>[Post.rating == 5, Post.user_id.in_([1,2])]\n</code></pre></p> About alias <p>When using alias, for example:</p> <pre><code>alias = aliased(Post) # table name will be `post_1`\n</code></pre> <p>the query cannot be executed like</p> <pre><code>db.query(alias).filter(*Post.filter_expr(rating=5))\n</code></pre> <p>because it will be compiled to</p> <pre><code>SELECT * FROM post_1 WHERE post.rating=5\n</code></pre> <p>which is wrong. The select is made from <code>post_1</code> but filter is based on <code>post</code>. Such filter will not work.</p> <p>A correct way to execute such query is</p> <pre><code>SELECT * FROM post_1 WHERE post_1.rating=5\n</code></pre> <p>For such case, this method (and other methods like <code>order_expr()</code> and <code>columns_expr()</code>) can be called ON ALIAS:</p> <pre><code>alias = aliased(Post)\ndb.query(alias).filter(*alias.filter_expr(rating=5))\n</code></pre> Note <p>This is a very low-level method. It is intended for more flexibility. It does not do magic Django-like joins. Use the high-level <code>smart_query()</code> method for that.</p> <p>Parameters</p> <ul> <li><code>filters</code>: Django-style filters.</li> </ul> <p>Returns</p> <ul> <li><code>list[sqlalchemy.sql.elements.ColumnElement[Any]]</code>: Filter expressions.</li> </ul> <p>Raises</p> <ul> <li><code>OperatorError</code>: If operator is not found.</li> <li><code>NoFilterableError</code>: If attribute is not filterable.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; Post.filter_expr(rating=5)\n[Post.rating == 5]\n&gt;&gt;&gt; db.query(Post).filter(*Post.filter_expr(rating=5))\nSELECT * FROM posts WHERE post.rating=5\n&gt;&gt;&gt; Post.filter_expr(rating=5, user_id__in=[1,2])\n[Post.rating == 5, Post.user_id.in_([1,2])]\n&gt;&gt;&gt; db.query(Post).filter(\n...     *Post.filter_expr(rating=5, user_id__in=[1,2])\n... )\nSELECT * FROM posts WHERE post.rating=5 AND post.user_id IN [1, 2]\n</code></pre></p> <p>Using alias: <pre><code>&gt;&gt;&gt; alias = aliased(Post)\n&gt;&gt;&gt; alias.filter_expr(rating=5)\n[Post.rating == 5]\n&gt;&gt;&gt; db.query(alias).filter(*alias.filter_expr(rating=5))\nSELECT * FROM post_1 WHERE post_1.rating=5\n&gt;&gt;&gt; alias.filter_expr(rating=5, user_id__in=[1,2])\n[Post.rating == 5, Post.user_id.in_([1,2])]\n&gt;&gt;&gt; db.query(alias).filter(\n...     *alias.filter_expr(rating=5, user_id__in=[1,2])\n... )\nSELECT * FROM post_1 WHERE post_1.rating=5 AND post_1.user_id IN [1, 2]\n</code></pre></p>"},{"location":"api/smart-query-mixin/#order_expr","title":"order_expr","text":"<pre><code>@classmethod\ndef order_expr(*columns: str) -&gt; list[ColumnElement[Any]]\n</code></pre> <p>Transform Django-style order expressions into SQLAlchemy expressions.</p> <p>Takes list of columns to order by like: <pre><code>['-rating', 'title']\n</code></pre> and returns list of expressions like: <pre><code>[desc(Post.rating), asc(Post.title)]\n</code></pre></p> About alias <p>See the <code>filter_expr()</code> method documentation for more information about using alias.</p> Note <p>This is a very low-level method. It is intended for more flexibility. It does not do magic Django-like joins. Use the high-level <code>smart_query()</code> method for that.</p> <p>Parameters</p> <ul> <li><code>columns</code>: Django-style sort expressions.</li> </ul> <p>Returns</p> <ul> <li><code>list[sqlalchemy.sql.elements.ColumnElement[Any]]</code>: Sort expressions.</li> </ul> <p>Raises</p> <ul> <li><code>NoSortableError</code>: If attribute is not sortable.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; Post.order_expr('-rating')\n[desc(Post.rating)]\n&gt;&gt;&gt; db.query(Post).order_by(*Post.order_expr('-rating'))\nSELECT * FROM posts ORDER BY posts.rating DESC\n&gt;&gt;&gt; Post.order_expr('-rating', 'title')\n[desc(Post.rating), asc(Post.title)]\n&gt;&gt;&gt; db.query(Post).order_by(\n...     *Post.order_expr('-rating', 'title')\n... )\nSELECT * FROM posts ORDER BY posts.rating DESC, posts.title ASC\n</code></pre></p> <p>Using alias: <pre><code>&gt;&gt;&gt; alias = aliased(Post)\n&gt;&gt;&gt; alias.order_expr('-rating')\n[desc(Post.rating)]\n&gt;&gt;&gt; db.query(alias).order_by(*alias.order_expr('-rating'))\nSELECT * FROM posts_1 ORDER BY posts_1.rating DESC\n&gt;&gt;&gt; alias.order_expr('-rating', 'title')\n[desc(Post.rating), asc(Post.title)]\n&gt;&gt;&gt; db.query(alias).order_by(*alias.order_expr('-rating', 'title'))\nSELECT * FROM posts_1 ORDER BY posts_1.rating DESC, posts_1.title ASC\n</code></pre></p>"},{"location":"api/smart-query-mixin/#columns_expr","title":"columns_expr","text":"<pre><code>@classmethod\ndef columns_expr(*columns: str) -&gt; list[ColumnElement[Any]]\n</code></pre> <p>Transform column names into SQLAlchemy model attributes.</p> <p>Takes list of column names like: <pre><code>['user_id', 'rating']\n</code></pre> and returns list of model attributes like: <pre><code>[Post.user_id, Post.rating]\n</code></pre> This method mostly used for grouping.</p> About alias <p>See the <code>filter_expr()</code> method documentation for more information about using alias.</p> Note <p>This is a very low-level method. It is intended for more flexibility. It does not do magic Django-like joins. Use the high-level <code>smart_query()</code> method for that.</p> <p>Parameters</p> <ul> <li><code>columns</code>: Column names.</li> </ul> <p>Returns</p> <ul> <li><code>list[sqlalchemy.sql.elements.ColumnElement[Any]]</code>: Model attributes.</li> </ul> <p>Raises</p> <ul> <li><code>NoColumnOrHybridPropertyError</code>: If attribute is neither a column nor a hybrid property.</li> </ul> <p>Examples</p> <p>Usage: <pre><code>&gt;&gt;&gt; Post.columns_expr('user_id')\n[Post.user_id]\n&gt;&gt;&gt; Post.columns_expr('user_id', 'rating')\n[Post.user_id, Post.rating]\n</code></pre></p> <p>Grouping: <pre><code>&gt;&gt;&gt; from sqlalchemy.sql import func\n&gt;&gt;&gt; db.query(Post.user_id, func.max(Post.rating))\n...   .group_by(*Post.columns_expr('user_id'))\nSELECT posts.user_id, max(posts.rating) FROM posts GROUP BY posts.user_id\n&gt;&gt;&gt; db.query(Post.user_id, Post.rating)\n...   .group_by(*Post.columns_expr('user_id', 'rating'))\nSELECT posts.user_id, posts.rating FROM posts GROUP BY posts.user_id, posts.rating\n</code></pre></p> <p>Using alias: <pre><code>&gt;&gt;&gt; alias = aliased(Post)\n&gt;&gt;&gt; alias.columns_expr('user_id')\n[Post.user_id]\n&gt;&gt;&gt; alias.columns_expr('user_id', 'rating')\n[Post.user_id, Post.rating]\n</code></pre></p> <p>Grouping on alias: <pre><code>&gt;&gt;&gt; db.query(alias.user_id, func.max(alias.rating))\n...   .group_by(*alias.columns_expr('user_id'))\nSELECT posts_1.user_id FROM posts_1 GROUP BY posts_1.user_id\n&gt;&gt;&gt; db.query(alias.user_id, alias.rating)\n...   .group_by(*alias.columns_expr('user_id', 'rating'))\nSELECT posts_1.user_id, posts_1.rating FROM posts_1 GROUP BY posts_1.user_id, posts_1.rating\n</code></pre></p>"},{"location":"api/smart-query-mixin/#eager_expr","title":"eager_expr","text":"<pre><code>@classmethod\ndef eager_expr(schema: EagerSchema) -&gt; list[_AbstractLoad]\n</code></pre> <p>Build eager loading expressions from the provided schema.</p> <p>Takes a schema like: <pre><code>schema = {\n    Post.user: 'joined',           # joinedload user\n    Post.comments: ('subquery', {  # load comments in separate query\n        Comment.user: 'joined'     # but, in this separate query, join user\n    })\n}\n</code></pre> and returns eager loading expressions like: <pre><code>[\n    joinedload(Post.user),\n    subqueryload(Post.comments).options(\n        joinedload(Comment.user)\n    )\n]\n</code></pre></p> <p>The supported eager loading strategies are: - <code>'joined'</code>: <code>sqlalchemy.orm.joinedload()</code> - <code>'subquery'</code>: <code>sqlalchemy.orm.subqueryload()</code> - <code>'selectin'</code>: <code>sqlalchemy.orm.selectinload()</code></p> <p>The constants <code>JOINED</code>, <code>SUBQUERY</code> and <code>SELECT_IN</code> are defined in the <code>sqlactive.definitions</code> module and can be used instead of the strings: <pre><code>&gt;&gt;&gt; from sqlactive.definitions import JOINED, SUBQUERY\n&gt;&gt;&gt; schema = {\n...     Post.user: JOINED,\n...     Post.comments: (SUBQUERY, {\n...         Comment.user: JOINED\n...     })\n... }\n</code></pre></p> <p>Parameters</p> <ul> <li><code>schema</code>: Schema for the eager loading.</li> </ul> <p>Returns</p> <ul> <li><code>list[sqlalchemy.orm.strategy_options._AbstractLoad]</code>: Eager loading expressions.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; schema = {\n...     Post.user: JOINED,\n...     Post.comments: (SUBQUERY, {Comment.user: SELECT_IN}),\n... }\n&gt;&gt;&gt; expressions = Post.eager_expr(schema)\n&gt;&gt;&gt; post1 = await Post.options(*expressions).limit(1).unique_one()\n&gt;&gt;&gt; post1.user.name\nBob Williams\n&gt;&gt;&gt; post1.comments[0].user.name\nBob Williams\n</code></pre>"},{"location":"api/smart-query-mixin/#smart_query","title":"smart_query","text":"<pre><code>@classmethod\ndef smart_query(\n    cls,\n    query: Query,\n    criteria: Sequence[_ColumnExpressionArgument[bool]] | None = None,\n    filters: DjangoFilters | None = None,\n    sort_columns: Sequence[_ColumnExpressionOrStrLabelArgument[Any]] | None = None,\n    sort_attrs: Sequence[str] | None = None,\n    group_columns: Sequence[_ColumnExpressionOrStrLabelArgument[Any]] | None = None,\n    group_attrs: Sequence[str] | None = None,\n    schema: EagerSchema | None = None,\n) -&gt; Query:\n</code></pre> <p>Create a query combining filtering, sorting, grouping and eager loading.</p> <p>Does magic <code>Django-like joins</code> like: <pre><code>post___user___name__startswith='Bob'\n</code></pre></p> <p>Does filtering, sorting, grouping and eager loading at the same time. And if, say, filters, sorting and grouping need the same join, it will be done only once.</p> <p>It also supports SQLAlchemy syntax like: <pre><code>&gt;&gt;&gt; db.query(User).filter(User.id == 1, User.name == 'Bob')\n&gt;&gt;&gt; db.query(User).filter(or_(User.id == 1, User.name == 'Bob'))\n&gt;&gt;&gt; db.query(Post).order_by(Post.rating.desc())\n&gt;&gt;&gt; db.query(Post).order_by(desc(Post.rating), asc(Post.user_id))\n</code></pre></p> Note <p>For more flexibility, you can use the <code>filter_expr()</code>, <code>order_expr()</code>, <code>columns_expr()</code> and <code>eager_expr()</code> methods.</p> <p>Parameters</p> <ul> <li><code>query</code>: Native SQLAlchemy query.</li> <li><code>criteria</code>: SQLAlchemy syntax filter expressions.</li> <li><code>filters</code>: Django-like filter expressions.</li> <li><code>sort_columns</code>: Standalone sort columns.</li> <li><code>sort_attrs</code>: Django-like sort expressions.</li> <li><code>group_columns</code>: Standalone group columns.</li> <li><code>group_attrs</code>: Django-like group expressions.</li> <li><code>schema</code>: Schema for the eager loading.</li> </ul> <p>Returns</p> <ul> <li><code>Query</code>: SQLAlchemy query with filtering, sorting, grouping and eager loading, that is to say, a beautiful smart query.</li> </ul> <p>Examples</p> <pre><code>&gt;&gt;&gt; query = User.smart_query(\n...     criteria=(or_(User.age == 30, User.age == 32),),\n...     filters={'username__like': '%8'},\n...     sort_columns=(User.username,),\n...     sort_attrs=('age',),\n...     schema={\n...         User.posts: JOINED,\n...         User.comments: (SUBQUERY, {\n...             Comment.post: SELECT_IN\n...         })\n...     },\n... )\n&gt;&gt;&gt; users = await query.unique_all()\n&gt;&gt;&gt; [user.username for user in users]\n['Bob28', 'Ian48', 'Jessica3248']\n&gt;&gt;&gt; users[0].posts[0].title\nLorem ipsum\n&gt;&gt;&gt; users[0].comments[0].post.title\nLorem ipsum\n</code></pre>"},{"location":"api/smart-query-mixin/#apply_search_filter","title":"apply_search_filter","text":"<pre><code>@classmethod\ndef apply_search_filter(\n    query: Query,\n    search_term: str,\n    columns: Sequence[str | InstrumentedAttribute[Any]] | None = None,\n) -&gt; Query\n</code></pre> <p>Apply a search filter to the query.</p> <p>Searches for <code>search_term</code> in the searchable columns of the model. If <code>columns</code> are provided, searches only these columns.</p> <p>Parameters</p> <ul> <li><code>query</code>: Native SQLAlchemy query.</li> <li><code>search_term</code>: Search term.</li> <li><code>columns</code>: Columns to search in.</li> </ul> <p>Returns</p> <ul> <li><code>Query</code>: SQLAlchemy query with the search filter applied.</li> </ul> <p>Examples</p> <p>To learn how to use this method, see the <code>search()</code> method. It uses this method internally.</p>"},{"location":"api/timestamp-mixin/","title":"Timestamp Mixin","text":"<p>The <code>TimestampMixin</code> class provides automatic timestamp functionality for SQLAlchemy models.</p>"},{"location":"api/timestamp-mixin/#customization","title":"Customization","text":""},{"location":"api/timestamp-mixin/#columns","title":"Columns","text":"<p>You can customize the timestamp columns by setting the <code>__created_at_name__</code> and <code>__updated_at_name__</code> class attributes:</p> <pre><code>class MyModel(TimestampMixin):\n    __created_at_name__ = 'created_at'\n    __updated_at_name__ = 'updated_at'\n</code></pre>"},{"location":"api/timestamp-mixin/#datetime-function","title":"Datetime function","text":"<p>You can customize the datetime function by setting the <code>__datetime_func__</code> class attribute:</p> <pre><code>from sqlalchemy.sql import func\n\nclass MyModel(TimestampMixin):\n    __datetime_func__ = func.current_timestamp()\n</code></pre>"}]}